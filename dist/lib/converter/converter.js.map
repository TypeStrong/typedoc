{"version":3,"file":"converter.js","sourceRoot":"","sources":["../../../src/lib/converter/converter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport * as _ts from '../ts-internal';\nimport * as _ from 'lodash';\n\nimport { Application } from '../application';\nimport { ParameterType } from '../utils/options/declaration';\nimport { Reflection, Type, ProjectReflection } from '../models/index';\nimport { Context } from './context';\nimport { ConverterComponent, ConverterNodeComponent, ConverterTypeComponent, TypeTypeConverter, TypeNodeConverter } from './components';\nimport { CompilerHost } from './utils/compiler-host';\nimport { Component, Option, ChildableComponent, ComponentClass } from '../utils/component';\nimport { normalizePath } from '../utils/fs';\n\n/**\n * Result structure of the [[Converter.convert]] method.\n */\nexport interface ConverterResult {\n    /**\n     * An array containing all errors generated by the TypeScript compiler.\n     */\n    errors: ReadonlyArray<ts.Diagnostic>;\n\n    /**\n     * The resulting project reflection.\n     */\n    project: ProjectReflection;\n}\n\n/**\n * Compiles source files using TypeScript and converts compiler symbols to reflections.\n */\n@Component({name: 'converter', internal: true, childClass: ConverterComponent})\nexport class Converter extends ChildableComponent<Application, ConverterComponent> {\n    /**\n     * The human readable name of the project. Used within the templates to set the title of the document.\n     */\n    @Option({\n        name: 'name',\n        help: 'Set the name of the project that will be used in the header of the template.'\n    })\n    name: string;\n\n    @Option({\n        name: 'externalPattern',\n        help: 'Define a pattern for files that should be considered being external.'\n    })\n    externalPattern: string;\n\n    @Option({\n        name: 'includeDeclarations',\n        help: 'Turn on parsing of .d.ts declaration files.',\n        type: ParameterType.Boolean\n    })\n    includeDeclarations: boolean;\n\n    @Option({\n        name: 'excludeExternals',\n        help: 'Prevent externally resolved TypeScript files from being documented.',\n        type: ParameterType.Boolean\n    })\n    excludeExternals: boolean;\n\n    @Option({\n        name: 'excludeNotExported',\n        help: 'Prevent symbols that are not exported from being documented.',\n        type: ParameterType.Boolean\n    })\n    excludeNotExported: boolean;\n\n    @Option({\n        name: 'excludePrivate',\n        help: 'Ignores private variables and methods',\n        type: ParameterType.Boolean\n    })\n    excludePrivate: boolean;\n\n    @Option({\n        name: 'excludeProtected',\n        help: 'Ignores protected variables and methods',\n        type: ParameterType.Boolean\n    })\n    excludeProtected: boolean;\n\n    private compilerHost: CompilerHost;\n\n    private nodeConverters: {[syntaxKind: number]: ConverterNodeComponent<ts.Node>};\n\n    private typeNodeConverters: TypeNodeConverter<ts.Type, ts.Node>[];\n\n    private typeTypeConverters: TypeTypeConverter<ts.Type>[];\n\n    /**\n     * General events\n     */\n\n    /**\n     * Triggered when the converter begins converting a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_BEGIN = 'begin';\n\n    /**\n     * Triggered when the converter has finished converting a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_END = 'end';\n\n    /**\n     * Factory events\n     */\n\n    /**\n     * Triggered when the converter begins converting a source file.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_FILE_BEGIN = 'fileBegin';\n\n    /**\n     * Triggered when the converter has created a declaration reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_DECLARATION = 'createDeclaration';\n\n    /**\n     * Triggered when the converter has created a signature reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_SIGNATURE = 'createSignature';\n\n    /**\n     * Triggered when the converter has created a parameter reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_PARAMETER = 'createParameter';\n\n    /**\n     * Triggered when the converter has created a type parameter reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_TYPE_PARAMETER = 'createTypeParameter';\n\n    /**\n     * Triggered when the converter has found a function implementation.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_FUNCTION_IMPLEMENTATION = 'functionImplementation';\n\n    /**\n     * Resolve events\n     */\n\n    /**\n     * Triggered when the converter begins resolving a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_RESOLVE_BEGIN = 'resolveBegin';\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     * The listener should implement [[IConverterResolveCallback]].\n     * @event\n     */\n    static EVENT_RESOLVE = 'resolveReflection';\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_RESOLVE_END = 'resolveEnd';\n\n    /**\n     * Create a new Converter instance.\n     *\n     * @param application  The application instance this converter relies on. The application\n     *   must expose the settings that should be used and serves as a global logging endpoint.\n     */\n    initialize() {\n        this.compilerHost = new CompilerHost(this);\n        this.nodeConverters = {};\n        this.typeTypeConverters = [];\n        this.typeNodeConverters = [];\n    }\n\n    addComponent<T extends ConverterComponent & Component>(name: string, componentClass: T | ComponentClass<T>): T {\n        const component = super.addComponent(name, componentClass);\n        if (component instanceof ConverterNodeComponent) {\n            this.addNodeConverter(component);\n        } else if (component instanceof ConverterTypeComponent) {\n            this.addTypeConverter(component);\n        }\n\n        return component;\n    }\n\n    private addNodeConverter(converter: ConverterNodeComponent<any>) {\n        for (let supports of converter.supports) {\n            this.nodeConverters[supports] = converter;\n        }\n    }\n\n    private addTypeConverter(converter: ConverterTypeComponent) {\n        if ('supportsNode' in converter && 'convertNode' in converter) {\n            this.typeNodeConverters.push(<TypeNodeConverter<any, any>> converter);\n            this.typeNodeConverters.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n        }\n\n        if ('supportsType' in converter && 'convertType' in converter) {\n            this.typeTypeConverters.push(<TypeTypeConverter<any>> converter);\n            this.typeTypeConverters.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n        }\n    }\n\n    removeComponent(name: string): ConverterComponent {\n        const component = super.removeComponent(name);\n        if (component instanceof ConverterNodeComponent) {\n            this.removeNodeConverter(component);\n        } else if (component instanceof ConverterTypeComponent) {\n            this.removeTypeConverter(component);\n        }\n\n        return component;\n    }\n\n    private removeNodeConverter(converter: ConverterNodeComponent<any>) {\n        const converters = this.nodeConverters;\n        const keys = _.keys(this.nodeConverters);\n        for (let key of keys) {\n            if (converters[key] === converter) {\n                delete converters[key];\n            }\n        }\n    }\n\n    private removeTypeConverter(converter: ConverterTypeComponent) {\n        const typeIndex = this.typeTypeConverters.indexOf(<any> converter);\n        if (typeIndex !== -1) {\n            this.typeTypeConverters.splice(typeIndex, 1);\n        }\n\n        const nodeIndex = this.typeNodeConverters.indexOf(<any> converter);\n        if (nodeIndex !== -1) {\n            this.typeNodeConverters.splice(nodeIndex, 1);\n        }\n    }\n\n    removeAllComponents() {\n        super.removeAllComponents();\n\n        this.nodeConverters = {};\n        this.typeTypeConverters = [];\n        this.typeNodeConverters = [];\n    }\n\n    /**\n     * Compile the given source files and create a project reflection for them.\n     *\n     * @param fileNames  Array of the file names that should be compiled.\n     */\n    convert(fileNames: string[]): ConverterResult {\n        for (let i = 0, c = fileNames.length; i < c; i++) {\n            fileNames[i] = normalizePath(_ts.normalizeSlashes(fileNames[i]));\n        }\n\n        const program = ts.createProgram(fileNames, this.application.options.getCompilerOptions(), this.compilerHost);\n        const checker = program.getTypeChecker();\n        const context = new Context(this, fileNames, checker, program);\n\n        this.trigger(Converter.EVENT_BEGIN, context);\n\n        const errors = this.compile(context);\n        const project = this.resolve(context);\n\n        this.trigger(Converter.EVENT_END, context);\n\n        return {\n            errors: errors,\n            project: project\n        };\n    }\n\n    /**\n     * Analyze the given node and create a suitable reflection.\n     *\n     * This function checks the kind of the node and delegates to the matching function implementation.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node     The compiler node that should be analyzed.\n     * @return The resulting reflection or NULL.\n     */\n    convertNode(context: Context, node: ts.Node): Reflection {\n        if (context.visitStack.indexOf(node) !== -1) {\n            return null;\n        }\n\n        const oldVisitStack = context.visitStack;\n        context.visitStack = oldVisitStack.slice();\n        context.visitStack.push(node);\n\n        let result: Reflection;\n        if (node.kind in this.nodeConverters) {\n            result = this.nodeConverters[node.kind].convert(context, node);\n        }\n\n        context.visitStack = oldVisitStack;\n        return result;\n    }\n\n    /**\n     * Convert the given TypeScript type into its TypeDoc type reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The node whose type should be reflected.\n     * @param type  The type of the node if already known.\n     * @returns The TypeDoc type reflection representing the given node and type.\n     */\n    convertType(context: Context, node?: ts.Node, type?: ts.Type): Type {\n        // Run all node based type conversions\n        if (node) {\n            type = type || context.getTypeAtLocation(node);\n\n            for (let converter of this.typeNodeConverters) {\n                if (converter.supportsNode(context, node, type)) {\n                    return converter.convertNode(context, node, type);\n                }\n            }\n        }\n\n        // Run all type based type conversions\n        if (type) {\n            for (let converter of this.typeTypeConverters) {\n                if (converter.supportsType(context, type)) {\n                    return converter.convertType(context, type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Compile the files within the given context and convert the compiler symbols to reflections.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns An array containing all errors generated by the TypeScript compiler.\n     */\n    private compile(context: Context): ReadonlyArray<ts.Diagnostic> {\n        const program = context.program;\n\n        program.getSourceFiles().forEach((sourceFile) => {\n            this.convertNode(context, sourceFile);\n        });\n\n        let diagnostics = program.getOptionsDiagnostics();\n        if (diagnostics.length) {\n            return diagnostics;\n        }\n\n        diagnostics = program.getSyntacticDiagnostics();\n        if (diagnostics.length) {\n            return diagnostics;\n        }\n\n        diagnostics = program.getGlobalDiagnostics();\n        if (diagnostics.length) {\n            return diagnostics;\n        }\n\n        diagnostics = program.getSemanticDiagnostics();\n        if (diagnostics.length) {\n            return diagnostics;\n        }\n\n        return [];\n    }\n\n    /**\n     * Resolve the project within the given context.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns The final project reflection.\n     */\n    private resolve(context: Context): ProjectReflection {\n        this.trigger(Converter.EVENT_RESOLVE_BEGIN, context);\n        const project = context.project;\n\n        for (let id in project.reflections) {\n            if (!project.reflections.hasOwnProperty(id)) {\n                continue;\n            }\n            this.trigger(Converter.EVENT_RESOLVE, context, project.reflections[id]);\n        }\n\n        this.trigger(Converter.EVENT_RESOLVE_END, context);\n        return project;\n    }\n\n    /**\n     * Return the basename of the default library that should be used.\n     *\n     * @returns The basename of the default library.\n     */\n    getDefaultLib(): string {\n        return ts.getDefaultLibFileName(this.application.options.getCompilerOptions());\n    }\n}\n"]}