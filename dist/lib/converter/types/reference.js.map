{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/reference.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { Type, IntrinsicType, ReflectionType } from '../../models/types/index';\nimport { ReflectionKind, DeclarationReflection } from '../../models/reflections/index';\nimport { createReferenceType } from '../factories/index';\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\nimport { Context } from '../context';\nimport { Converter } from '../converter';\n\n@Component({name: 'type:reference'})\nexport class ReferenceConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.TypeReference, ts.TypeReferenceNode> {\n    /**\n     * The priority this converter should be executed with.\n     * A higher priority means the converter will be applied earlier.\n     */\n    priority = -50;\n\n    /**\n     * Test whether this converter can handle the given TypeScript node.\n     */\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): boolean {\n        return !!(type.flags & ts.TypeFlags.Object);\n    }\n\n    /**\n     * Test whether this converter can handle the given TypeScript type.\n     */\n    supportsType(context: Context, type: ts.TypeReference): boolean {\n        return !!(type.flags & ts.TypeFlags.Object);\n    }\n\n    /**\n     * Convert the type reference node to its type reflection.\n     *\n     * This is a node based converter, see [[convertTypeReferenceType]] for the type equivalent.\n     *\n     * ```\n     * class SomeClass { }\n     * let someValue: SomeClass;\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The type reference node that should be converted.\n     * @param type  The type of the type reference node.\n     * @returns The type reflection representing the given reference node.\n     */\n    convertNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): Type | undefined {\n        if (!type.symbol) {\n            return new IntrinsicType('Object');\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\n            return this.convertLiteral(context, type.symbol, node);\n        }\n\n        const result = createReferenceType(context, type.symbol);\n        if (result && node.typeArguments) {\n            result.typeArguments = this.owner.convertTypes(context, node.typeArguments);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert the given type reference to its type reflection.\n     *\n     * This is a type based converter, see [[convertTypeReference]] for the node equivalent.\n     *\n     * ```\n     * class SomeClass { }\n     * let someValue: SomeClass;\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param type  The type reference that should be converted.\n     * @returns The type reflection representing the given type reference.\n     */\n    convertType(context: Context, type: ts.TypeReference): Type | undefined {\n        if (!type.symbol) {\n            return new IntrinsicType('Object');\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\n            return this.convertLiteral(context, type.symbol);\n        }\n\n        const result = createReferenceType(context, type.symbol);\n        if (result && type.typeArguments) {\n            result.typeArguments = this.owner.convertTypes(context, undefined, type.typeArguments);\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a type literal reflection.\n     *\n     * This is a utility function used by [[convertTypeReferenceNode]] and\n     * [[convertTypeReferenceType]] when encountering an object or type literal.\n     *\n     * A type literal is explicitly set:\n     * ```\n     * let someValue: {a: string; b: number;};\n     * ```\n     *\n     * An object literal types are usually reflected by the TypeScript compiler:\n     * ```\n     * function someFunction() { return {a: 'Test', b: 1024}; }\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param symbol  The symbol describing the type literal.\n     * @param node  If known the node which produced the type literal. Type literals that are\n     *   implicitly generated by TypeScript won't have a corresponding node.\n     * @returns A type reflection representing the given type literal.\n     */\n    private convertLiteral(context: Context, symbol: ts.Symbol, node?: ts.Node): Type | undefined {\n        for (let declaration of symbol.declarations) {\n            if (context.visitStack.includes(declaration)) {\n                if (declaration.kind === ts.SyntaxKind.TypeLiteral ||\n                        declaration.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n                    // TODO: Check if this type assertion is safe and document.\n                    return createReferenceType(context, declaration.parent.symbol!);\n                } else {\n                    // TODO: Check if this type assertion is safe and document.\n                    return createReferenceType(context, declaration.symbol!);\n                }\n            }\n        }\n\n        const declaration = new DeclarationReflection('__type', ReflectionKind.TypeLiteral, context.scope);\n\n        context.registerReflection(declaration, undefined, symbol);\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, declaration, node);\n        context.withScope(declaration, () => {\n            symbol.declarations.forEach((node) => {\n                this.owner.convertNode(context, node);\n            });\n        });\n\n        return new ReflectionType(declaration);\n    }\n}\n"]}