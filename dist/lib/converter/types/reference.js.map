{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/reference.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { Type, IntrinsicType, ReflectionType } from '../../models/types/index';\nimport { ReflectionKind, DeclarationReflection } from '../../models/reflections/index';\nimport { createReferenceType } from '../factories/index';\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\nimport { Context } from '../context';\nimport { Converter } from '../converter';\n\n@Component({name: 'type:reference'})\nexport class ReferenceConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.TypeReference, ts.TypeReferenceNode> {\n    /**\n     * The priority this converter should be executed with.\n     * A higher priority means the converter will be applied earlier.\n     */\n    priority = -50;\n\n    /**\n     * Test whether this converter can handle the given TypeScript node.\n     */\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): boolean {\n        return !!(type.flags & ts.TypeFlags.Object);\n    }\n\n    /**\n     * Test whether this converter can handle the given TypeScript type.\n     */\n    supportsType(context: Context, type: ts.TypeReference): boolean {\n        return !!(type.flags & ts.TypeFlags.Object);\n    }\n\n    /**\n     * Convert the type reference node to its type reflection.\n     *\n     * This is a node based converter, see [[convertTypeReferenceType]] for the type equivalent.\n     *\n     * ```\n     * class SomeClass { }\n     * let someValue: SomeClass;\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The type reference node that should be converted.\n     * @param type  The type of the type reference node.\n     * @returns The type reflection representing the given reference node.\n     */\n    convertNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): Type {\n        if (!type.symbol) {\n            return new IntrinsicType('Object');\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\n            return this.convertLiteral(context, type.symbol, node);\n        }\n\n        const result = createReferenceType(context, type.symbol);\n        if (node.typeArguments) {\n            result.typeArguments = node.typeArguments.map((n) => this.owner.convertType(context, n));\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert the given type reference to its type reflection.\n     *\n     * This is a type based converter, see [[convertTypeReference]] for the node equivalent.\n     *\n     * ```\n     * class SomeClass { }\n     * let someValue: SomeClass;\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param type  The type reference that should be converted.\n     * @returns The type reflection representing the given type reference.\n     */\n    convertType(context: Context, type: ts.TypeReference): Type {\n        if (!type.symbol) {\n            return new IntrinsicType('Object');\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\n            return this.convertLiteral(context, type.symbol);\n        }\n\n        const result = createReferenceType(context, type.symbol);\n        if (type.typeArguments) {\n            result.typeArguments = type.typeArguments.map((t) => this.owner.convertType(context, null, t));\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a type literal reflection.\n     *\n     * This is a utility function used by [[convertTypeReferenceNode]] and\n     * [[convertTypeReferenceType]] when encountering an object or type literal.\n     *\n     * A type literal is explicitly set:\n     * ```\n     * let someValue: {a: string; b: number;};\n     * ```\n     *\n     * An object literal types are usually reflected by the TypeScript compiler:\n     * ```\n     * function someFunction() { return {a: 'Test', b: 1024}; }\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param symbol  The symbol describing the type literal.\n     * @param node  If known the node which produced the type literal. Type literals that are\n     *   implicitly generated by TypeScript won't have a corresponding node.\n     * @returns A type reflection representing the given type literal.\n     */\n    private convertLiteral(context: Context, symbol: ts.Symbol, node?: ts.Node): Type {\n        for (let declaration of symbol.declarations) {\n            if (context.visitStack.indexOf(declaration) !== -1) {\n                if (declaration.kind === ts.SyntaxKind.TypeLiteral ||\n                        declaration.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n                    return createReferenceType(context, declaration.parent.symbol);\n                } else {\n                    return createReferenceType(context, declaration.symbol);\n                }\n            }\n        }\n\n        const declaration = new DeclarationReflection();\n        declaration.kind = ReflectionKind.TypeLiteral;\n        declaration.name = '__type';\n        declaration.parent = context.scope;\n\n        context.registerReflection(declaration, null, symbol);\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, declaration, node);\n        context.withScope(declaration, () => {\n            symbol.declarations.forEach((node) => {\n                this.owner.convertNode(context, node);\n            });\n        });\n\n        return new ReflectionType(declaration);\n    }\n}\n"]}