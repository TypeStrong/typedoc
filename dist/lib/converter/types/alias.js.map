{"version":3,"file":"alias.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/alias.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AACA,uCAAyC;AAEzC,4CAAmD;AACnD,4CAAqF;AAIrF;IAAoC,kCAAsB;IAD1D;QAAA,qEA2EC;QArEG,cAAQ,GAAG,GAAG,CAAC;;IAqEnB,CAAC;IAvDG,qCAAY,GAAZ,UAAa,OAAgB,EAAE,IAA0B,EAAE,IAAa;QACpE,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YACnC,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;QAChC,IAAI,UAAU,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;YACrC,UAAU,CAAC,KAAK,EAAE,CAAC;QACvB,CAAC;QAED,IAAI,QAAQ,GAAG,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC3D,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YACnB,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QAED,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC1D,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QACvC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QAEnC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACvD,CAAC;IAkBD,oCAAW,GAAX,UAAY,OAAgB,EAAE,IAA0B;QAAxD,iBASC;QARG,IAAM,IAAI,GAAG,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAM,MAAM,GAAG,IAAI,qBAAa,CAAC,IAAI,EAAE,qBAAa,CAAC,yBAAyB,CAAC,CAAC;QAEhF,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC,EAAlC,CAAkC,CAAC,CAAC;QAC3F,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAzEQ,cAAc;QAD1B,sBAAS,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC;OACnB,cAAc,CA0E1B;IAAD,qBAAC;CAAA,AA1ED,CAAoC,mCAAsB,GA0EzD;AA1EY,wCAAc","sourcesContent":["import * as ts from 'typescript';\nimport * as _ts from '../../ts-internal';\n\nimport { ReferenceType } from '../../models/index';\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\nimport { Context } from '../context';\n\n@Component({name: 'type:alias'})\nexport class AliasConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.Type, ts.TypeReferenceNode> {\n    /**\n     * The priority this converter should be executed with.\n     * A higher priority means the converter will be applied earlier.\n     */\n    priority = 100;\n\n    /**\n     * Test whether the given node and type definitions represent a type alias.\n     *\n     * The compiler resolves type aliases pretty early and there is no field telling us\n     * whether the given node was a type alias or not. So we have to compare the type name of the\n     * node with the type name of the type symbol.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The node that should be tested.\n     * @param type  The type of the node that should be tested.\n     * @returns TRUE when the given node and type look like a type alias, otherwise FALSE.\n     */\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.Type): boolean {\n        if (!type || !node || !node.typeName) {\n            return false;\n        }\n        if (!type.symbol) {\n            return true;\n        }\n\n        const checker = context.checker;\n        let symbolName = checker.getFullyQualifiedName(type.symbol).split('.');\n        if (!symbolName.length) {\n            return false;\n        }\n        if (symbolName[0].substr(0, 1) === '\"') {\n            symbolName.shift();\n        }\n\n        let nodeName = _ts.getTextOfNode(node.typeName).split('.');\n        if (!nodeName.length) {\n            return false;\n        }\n\n        let common = Math.min(symbolName.length, nodeName.length);\n        symbolName = symbolName.slice(-common);\n        nodeName = nodeName.slice(-common);\n\n        return nodeName.join('.') !== symbolName.join('.');\n    }\n\n    /**\n     * Create a reflection for the given type alias node.\n     *\n     * This is a node based converter with no type equivalent.\n     *\n     * Use [[isTypeAlias]] beforehand to test whether a given type/node combination is\n     * pointing to a type alias.\n     *\n     * ```\n     * type MyNumber = number;\n     * let someValue: MyNumber;\n     * ```\n     *\n     * @param node  The node whose type should be reflected.\n     * @returns  A type reference pointing to the type alias definition.\n     */\n    convertNode(context: Context, node: ts.TypeReferenceNode): ReferenceType {\n        const name = _ts.getTextOfNode(node.typeName);\n        const result = new ReferenceType(name, ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME);\n\n        if (node.typeArguments) {\n            result.typeArguments = node.typeArguments.map(n => this.owner.convertType(context, n));\n        }\n\n        return result;\n    }\n}\n"]}