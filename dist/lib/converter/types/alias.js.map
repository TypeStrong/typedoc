{"version":3,"file":"alias.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/alias.ts"],"names":[],"mappings":";;;;;;;;AAEA,8CAAmD;AACnD,8CAAqF;AAIrF,IAAa,cAAc,GAA3B,MAAa,cAAe,SAAQ,mCAAsB;IAD1D;;QAMI,aAAQ,GAAG,GAAG,CAAC;IAqEnB,CAAC;IAvDG,YAAY,CAAC,OAAgB,EAAE,IAA0B,EAAE,IAAa;QACpE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClC,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,OAAO,IAAI,CAAC;SACf;QAED,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;QAChC,IAAI,UAAU,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvE,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;YACpB,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;YACpC,UAAU,CAAC,KAAK,EAAE,CAAC;SACtB;QAED,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAClD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YAClB,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC1D,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QACvC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;QAEnC,OAAO,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACvD,CAAC;IAkBD,WAAW,CAAC,OAAgB,EAAE,IAA0B;QACpD,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;QACrC,MAAM,MAAM,GAAG,IAAI,qBAAa,CAAC,IAAI,EAAE,qBAAa,CAAC,yBAAyB,CAAC,CAAC;QAEhF,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;SAC/E;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;CACJ,CAAA;AA1EY,cAAc;IAD1B,sBAAS,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC;GACnB,cAAc,CA0E1B;AA1EY,wCAAc","sourcesContent":["import * as ts from 'typescript';\n\nimport { ReferenceType } from '../../models/index';\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\nimport { Context } from '../context';\n\n@Component({name: 'type:alias'})\nexport class AliasConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.Type, ts.TypeReferenceNode> {\n    /**\n     * The priority this converter should be executed with.\n     * A higher priority means the converter will be applied earlier.\n     */\n    priority = 100;\n\n    /**\n     * Test whether the given node and type definitions represent a type alias.\n     *\n     * The compiler resolves type aliases pretty early and there is no field telling us\n     * whether the given node was a type alias or not. So we have to compare the type name of the\n     * node with the type name of the type symbol.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The node that should be tested.\n     * @param type  The type of the node that should be tested.\n     * @returns TRUE when the given node and type look like a type alias, otherwise FALSE.\n     */\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.Type): boolean {\n        if (!type || !node || !node.typeName) {\n            return false;\n        }\n        if (!type.symbol) {\n            return true;\n        }\n\n        const checker = context.checker;\n        let symbolName = checker.getFullyQualifiedName(type.symbol).split('.');\n        if (!symbolName.length) {\n            return false;\n        }\n        if (symbolName[0].substr(0, 1) === '\"') {\n            symbolName.shift();\n        }\n\n        let nodeName = node.typeName.getText().split('.');\n        if (!nodeName.length) {\n            return false;\n        }\n\n        let common = Math.min(symbolName.length, nodeName.length);\n        symbolName = symbolName.slice(-common);\n        nodeName = nodeName.slice(-common);\n\n        return nodeName.join('.') !== symbolName.join('.');\n    }\n\n    /**\n     * Create a reflection for the given type alias node.\n     *\n     * This is a node based converter with no type equivalent.\n     *\n     * Use [[isTypeAlias]] beforehand to test whether a given type/node combination is\n     * pointing to a type alias.\n     *\n     * ```\n     * type MyNumber = number;\n     * let someValue: MyNumber;\n     * ```\n     *\n     * @param node  The node whose type should be reflected.\n     * @returns  A type reference pointing to the type alias definition.\n     */\n    convertNode(context: Context, node: ts.TypeReferenceNode): ReferenceType {\n        const name = node.typeName.getText();\n        const result = new ReferenceType(name, ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME);\n\n        if (node.typeArguments) {\n            result.typeArguments = this.owner.convertTypes(context, node.typeArguments);\n        }\n\n        return result;\n    }\n}\n"]}