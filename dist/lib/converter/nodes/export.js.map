{"version":3,"file":"export.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/export.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { Reflection, ReflectionFlag, DeclarationReflection, ReflectionKind } from '../../models/index';\nimport { Context } from '../context';\nimport { Component, ConverterNodeComponent } from '../components';\nimport { createDeclaration } from '../factories';\n\n@Component({name: 'node:export'})\nexport class ExportConverter extends ConverterNodeComponent<ts.ExportAssignment> {\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports: ts.SyntaxKind[] = [\n        ts.SyntaxKind.ExportAssignment,\n        ts.SyntaxKind.ExportDeclaration\n    ];\n\n    private _convertExportAllDeclaration(context: Context, moduleSpecifier: ts.Expression): Reflection | undefined {\n        const symbol = context.checker.getSymbolAtLocation(moduleSpecifier);\n        if (!symbol) {\n            return context.scope;\n        }\n\n        const valueDeclaration = symbol.valueDeclaration;\n        if (!valueDeclaration) {\n            return context.scope;\n        }\n\n        if (!ts.isSourceFile(valueDeclaration)) {\n            return context.scope;\n        }\n\n        valueDeclaration.statements.forEach((statement) => {\n            this.owner.convertNode(context, statement);\n        });\n\n        return context.scope;\n    }\n\n    private _convertExportDeclaration(context: Context, node: ts.ExportDeclaration): Reflection | undefined {\n        if (node.moduleSpecifier) {\n            // export * from 'xxx';\n            return this._convertExportAllDeclaration(context, node.moduleSpecifier);\n        }\n\n        if (!node.exportClause) {\n            return context.scope;\n        }\n\n        // export { xx, xx as yy };\n        node.exportClause.elements.forEach((element) => {\n            // export { q as quat };\n            // q: propertyName\n            // quat: name\n            // export { quat };\n            // quat: name\n            const exportedSymbol = context.checker.getSymbolAtLocation(element.name);\n            if (exportedSymbol) {\n                const originalSymbol = context.checker.getAliasedSymbol(exportedSymbol);\n                const declarations = originalSymbol.getDeclarations();\n                if (declarations) {\n                    declarations.forEach((declaration) => {\n                        if (ts.isSourceFile(declaration)) {\n                            // import * as xx from 'xx';\n                            // export {xx};\n                            const reflection = createDeclaration(context, element.name, ReflectionKind.Module, exportedSymbol.name);\n                            if (reflection) {\n                                reflection.setFlag(ReflectionFlag.Exported);\n                                context.withScope(reflection, () => {\n                                    declaration.statements.forEach((statement) => {\n                                        this.owner.convertNode(context, statement);\n                                    });\n                                });\n                            }\n                        } else {\n                            const reflection = this.owner.convertNode(context, declaration);\n                            if (reflection) {\n                                reflection.setFlag(ReflectionFlag.Exported);\n                                reflection.name = exportedSymbol.name;\n                            }\n                        }\n                    });\n                }\n            }\n        });\n\n        return context.scope;\n    }\n\n    convert(context: Context, node: ts.ExportAssignment | ts.ExportDeclaration): Reflection | undefined {\n        if (ts.isExportDeclaration(node)) {\n            return this._convertExportDeclaration(context, node);\n        }\n\n        let symbol: ts.Symbol | undefined;\n\n        // default export\n        if (node.symbol && (node.symbol.flags & ts.SymbolFlags.Alias) === ts.SymbolFlags.Alias) {\n            symbol = context.checker.getAliasedSymbol(node.symbol);\n        } else {\n            let type = context.getTypeAtLocation(node.expression);\n            symbol = type ? type.symbol : undefined;\n        }\n        if (symbol && symbol.declarations) {\n            const project = context.project;\n            symbol.declarations.forEach((declaration) => {\n                if (!declaration.symbol) {\n                    return;\n                }\n                const id = project.symbolMapping[context.getSymbolID(declaration.symbol)!];\n                if (!id) {\n                    return;\n                }\n\n                const reflection = project.reflections[id];\n                if (node.isExportEquals && reflection instanceof DeclarationReflection) {\n                    reflection.setFlag(ReflectionFlag.ExportAssignment, true);\n                }\n                markAsExported(reflection);\n            });\n        }\n\n        function markAsExported(reflection: Reflection) {\n            if (reflection instanceof DeclarationReflection) {\n                reflection.setFlag(ReflectionFlag.Exported, true);\n            }\n\n            reflection.traverse(markAsExported);\n        }\n\n        return context.scope;\n    }\n}\n"]}