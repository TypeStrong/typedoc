{"version":3,"file":"function.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/function.ts"],"names":[],"mappings":";;;;;;;;AAAA,iCAAiC;AAEjC,8CAAgF;AAChF,8CAAwE;AAExE,4CAAyC;AACzC,8CAAkE;AAGlE,IAAa,iBAAiB,GAA9B,MAAa,iBAAkB,SAAQ,mCAAmE;IAD1G;;QAKI,aAAQ,GAAoB;YACxB,EAAE,CAAC,UAAU,CAAC,eAAe;YAC7B,EAAE,CAAC,UAAU,CAAC,iBAAiB;YAC/B,EAAE,CAAC,UAAU,CAAC,mBAAmB;SACpC,CAAC;IAoCN,CAAC;IA3BG,OAAO,CAAC,OAAgB,EAAE,IAAiD;QACvE,MAAM,KAAK,GAAK,OAAO,CAAC,KAAK,CAAC;QAC9B,MAAM,IAAI,GAAM,KAAK,CAAC,IAAI,GAAG,sBAAc,CAAC,gBAAgB,CAAC,CAAC,CAAC,sBAAc,CAAC,MAAM,CAAC,CAAC,CAAC,sBAAc,CAAC,QAAQ,CAAC;QAC/G,MAAM,OAAO,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAC5B,MAAM,MAAM,GAAI,yBAAiB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAEvD,IAAI,MAAM;eACH,IAAI,GAAG,sBAAc,CAAC,MAAM;eAC5B,IAAI,CAAC,SAAS;eACd,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,eAAe,CAAE,EAAE;YAC3E,MAAM,CAAC,OAAO,CAAC,sBAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SAC/C;QAED,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE,GAAG,EAAE;YAC3B,IAAI,CAAC,OAAO,IAAI,CAAC,MAAO,CAAC,UAAU,EAAE;gBACjC,MAAM,SAAS,GAAG,uBAAe,CAAC,OAAO,EAA4B,IAAI,EAAE,MAAO,CAAC,IAAI,EAAE,sBAAc,CAAC,aAAa,CAAC,CAAC;gBACvH,IAAI,CAAC,MAAO,CAAC,UAAU,EAAE;oBACrB,MAAO,CAAC,UAAU,GAAG,EAAE,CAAC;iBAC3B;gBACD,MAAO,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACtC;iBAAM;gBACH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,6BAA6B,EAAE,MAAO,EAAY,IAAI,CAAC,CAAC;aACrF;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC;IAClB,CAAC;CACJ,CAAA;AA5CY,iBAAiB;IAD7B,sBAAS,CAAC,EAAC,IAAI,EAAE,eAAe,EAAC,CAAC;GACtB,iBAAiB,CA4C7B;AA5CY,8CAAiB","sourcesContent":["import * as ts from 'typescript';\n\nimport { Reflection, ReflectionFlag, ReflectionKind } from '../../models/index';\nimport { createDeclaration, createSignature } from '../factories/index';\nimport { Context } from '../context';\nimport { Converter } from '../converter';\nimport { Component, ConverterNodeComponent } from '../components';\n\n@Component({name: 'node:function'})\nexport class FunctionConverter extends ConverterNodeComponent<ts.FunctionDeclaration|ts.MethodDeclaration> {\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports: ts.SyntaxKind[] = [\n        ts.SyntaxKind.MethodSignature,\n        ts.SyntaxKind.MethodDeclaration,\n        ts.SyntaxKind.FunctionDeclaration\n    ];\n\n    /**\n     * Analyze the given function declaration node and create a suitable reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node     The function declaration node that should be analyzed.\n     * @return The resulting reflection or NULL.\n     */\n    convert(context: Context, node: ts.FunctionDeclaration|ts.MethodDeclaration): Reflection | undefined {\n        const scope   = context.scope;\n        const kind    = scope.kind & ReflectionKind.ClassOrInterface ? ReflectionKind.Method : ReflectionKind.Function;\n        const hasBody = !!node.body;\n        const method  = createDeclaration(context, node, kind);\n\n        if (method  // child inheriting will return null on createDeclaration\n            && kind & ReflectionKind.Method\n            && node.modifiers\n            && node.modifiers.some( m => m.kind === ts.SyntaxKind.AbstractKeyword )) {\n          method.setFlag(ReflectionFlag.Abstract, true);\n        }\n\n        context.withScope(method, () => {\n            if (!hasBody || !method!.signatures) {\n                const signature = createSignature(context, <ts.SignatureDeclaration> node, method!.name, ReflectionKind.CallSignature);\n                if (!method!.signatures) {\n                    method!.signatures = [];\n                }\n                method!.signatures.push(signature);\n            } else {\n                context.trigger(Converter.EVENT_FUNCTION_IMPLEMENTATION, method!, <ts.Node> node);\n            }\n        });\n\n        return method;\n    }\n}\n"]}