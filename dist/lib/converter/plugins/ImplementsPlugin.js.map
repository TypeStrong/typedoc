{"version":3,"file":"ImplementsPlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/ImplementsPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ReflectionKind, DeclarationReflection, SignatureReflection } from '../../models/reflections/index';\nimport { Type, ReferenceType } from '../../models/types/index';\nimport { Component, ConverterComponent } from '../components';\nimport { Converter } from '../converter';\nimport { Context } from '../context';\n\n/**\n * A plugin that detects interface implementations of functions and\n * properties on classes and links them.\n */\n@Component({name: 'implements'})\nexport class ImplementsPlugin extends ConverterComponent {\n    /**\n     * Create a new ImplementsPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, Converter.EVENT_RESOLVE, this.onResolve, -10);\n    }\n\n    /**\n     * Mark all members of the given class to be the implementation of the matching interface member.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param classReflection  The reflection of the classReflection class.\n     * @param interfaceReflection  The reflection of the interfaceReflection interface.\n     */\n    private analyzeClass(context: Context, classReflection: DeclarationReflection, interfaceReflection: DeclarationReflection) {\n        if (!interfaceReflection.children) {\n            return;\n        }\n\n        interfaceReflection.children.forEach((interfaceMember: DeclarationReflection) => {\n            if (!(interfaceMember instanceof DeclarationReflection)) {\n                return;\n            }\n\n            let classMember: DeclarationReflection | undefined;\n\n            if (!classReflection.children) {\n                return;\n            }\n\n            for (let index = 0, count = classReflection.children.length; index < count; index++) {\n                const child = classReflection.children[index];\n                if (child.name !== interfaceMember.name) {\n                    continue;\n                }\n                if (child.flags.isStatic !== interfaceMember.flags.isStatic) {\n                    continue;\n                }\n\n                classMember = child;\n                break;\n            }\n\n            if (!classMember) {\n                return;\n            }\n\n            const interfaceMemberName = interfaceReflection.name + '.' + interfaceMember.name;\n            classMember.implementationOf = new ReferenceType(interfaceMemberName, ReferenceType.SYMBOL_ID_RESOLVED, interfaceMember);\n            this.copyComment(classMember, interfaceMember);\n\n            if (interfaceMember.kindOf(ReflectionKind.FunctionOrMethod) && interfaceMember.signatures && classMember.signatures) {\n                interfaceMember.signatures.forEach((interfaceSignature: SignatureReflection) => {\n                    const interfaceParameters = interfaceSignature.getParameterTypes();\n                    (classMember!.signatures || []).forEach((classSignature: SignatureReflection) => {\n                        if (Type.isTypeListEqual(interfaceParameters, classSignature.getParameterTypes())) {\n                            classSignature.implementationOf = new ReferenceType(interfaceMemberName, ReferenceType.SYMBOL_ID_RESOLVED, interfaceSignature);\n                            this.copyComment(classSignature, interfaceSignature);\n                        }\n                    });\n                });\n            }\n        });\n    }\n\n    /**\n     * Copy the comment of the source reflection to the target reflection.\n     *\n     * @param target\n     * @param source\n     */\n    private copyComment(target: Reflection, source: Reflection) {\n        if (target.comment && source.comment && target.comment.hasTag('inheritdoc')) {\n            target.comment.copyFrom(source.comment);\n\n            if (target instanceof SignatureReflection && target.parameters &&\n                source instanceof SignatureReflection && source.parameters) {\n                for (let index = 0, count = target.parameters.length; index < count; index++) {\n                    if (target.parameters[index].comment) {\n                        target.parameters[index].comment!.copyFrom(source.parameters[index].comment!);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: DeclarationReflection) {\n        if (reflection.kindOf(ReflectionKind.Class) && reflection.implementedTypes) {\n            reflection.implementedTypes.forEach((type: Type) => {\n                if (!(type instanceof ReferenceType)) {\n                    return;\n                }\n\n                if (type.reflection && type.reflection.kindOf(ReflectionKind.Interface)) {\n                    this.analyzeClass(context, reflection, <DeclarationReflection> type.reflection);\n                }\n            });\n        }\n    }\n}\n"]}