{"version":3,"file":"ImplementsPlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/ImplementsPlugin.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,wDAAwH;AACxH,kDAA+D;AAC/D,4CAA8D;AAC9D,0CAAyC;AAQzC;IAAsC,oCAAkB;IAAxD;;IA2GA,CAAC;IAvGG,qCAAU,GAAV;QACI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,qBAAS,CAAC,aAAa,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;IAC5E,CAAC;IASO,uCAAY,GAApB,UAAqB,OAAgB,EAAE,eAAsC,EAAE,mBAA0C;QAAzH,iBAiDC;QAhDG,EAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC,CAAC;YAChC,MAAM,CAAC;QACX,CAAC;QAED,mBAAmB,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAC,eAAsC;YACxE,EAAE,CAAC,CAAC,CAAC,CAAC,eAAe,YAAY,6BAAqB,CAAC,CAAC,CAAC,CAAC;gBACtD,MAAM,CAAC;YACX,CAAC;YAED,IAAI,WAAkC,CAAC;YAEvC,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC;YACX,CAAC;YAED,GAAG,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,eAAe,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK,EAAE,EAAE,CAAC;gBAClF,IAAM,KAAK,GAAG,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAC9C,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;oBACtC,QAAQ,CAAC;gBACb,CAAC;gBACD,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,KAAK,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC1D,QAAQ,CAAC;gBACb,CAAC;gBAED,WAAW,GAAG,KAAK,CAAC;gBACpB,KAAK,CAAC;YACV,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC;YACX,CAAC;YAED,IAAM,mBAAmB,GAAG,mBAAmB,CAAC,IAAI,GAAG,GAAG,GAAG,eAAe,CAAC,IAAI,CAAC;YAClF,WAAW,CAAC,gBAAgB,GAAG,IAAI,qBAAa,CAAC,mBAAmB,EAAE,qBAAa,CAAC,kBAAkB,EAAE,eAAe,CAAC,CAAC;YACzH,KAAI,CAAC,WAAW,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;YAE/C,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,sBAAc,CAAC,gBAAgB,CAAC,IAAI,eAAe,CAAC,UAAU,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC;gBAClH,eAAe,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,kBAAuC;oBACvE,IAAM,mBAAmB,GAAG,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;oBACnE,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,cAAmC;wBAC/D,EAAE,CAAC,CAAC,YAAI,CAAC,eAAe,CAAC,mBAAmB,EAAE,cAAc,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAC;4BAChF,cAAc,CAAC,gBAAgB,GAAG,IAAI,qBAAa,CAAC,mBAAmB,EAAE,qBAAa,CAAC,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;4BAC/H,KAAI,CAAC,WAAW,CAAC,cAAc,EAAE,kBAAkB,CAAC,CAAC;wBACzD,CAAC;oBACL,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,CAAC;YACP,CAAC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAQO,sCAAW,GAAnB,UAAoB,MAAkB,EAAE,MAAkB;QACtD,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YAC1E,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAExC,EAAE,CAAC,CAAC,MAAM,YAAY,2BAAmB,IAAI,MAAM,CAAC,UAAU;gBAC1D,MAAM,YAAY,2BAAmB,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBAC7D,GAAG,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK,EAAE,EAAE,CAAC;oBAC3E,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;wBACnC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC;oBAChF,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IAQO,oCAAS,GAAjB,UAAkB,OAAgB,EAAE,UAAiC;QAArE,iBAaC;QAZG,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,sBAAc,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC;YACzE,UAAU,CAAC,gBAAgB,CAAC,OAAO,CAAC,UAAC,IAAU;gBAC3C,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,YAAY,qBAAa,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,CAAC;gBACX,CAAC;gBAED,IAAM,MAAM,GAA4C,IAAK,CAAC,UAAU,CAAC;gBACzE,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,sBAAc,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBACpD,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;gBACnD,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC;IACL,CAAC;IA1GQ,gBAAgB;QAD5B,sBAAS,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC;OACnB,gBAAgB,CA2G5B;IAAD,uBAAC;CAAA,AA3GD,CAAsC,+BAAkB,GA2GvD;AA3GY,4CAAgB","sourcesContent":["import { Reflection, ReflectionKind, DeclarationReflection, SignatureReflection } from '../../models/reflections/index';\nimport { Type, ReferenceType } from '../../models/types/index';\nimport { Component, ConverterComponent } from '../components';\nimport { Converter } from '../converter';\nimport { Context } from '../context';\n\n/**\n * A plugin that detects interface implementations of functions and\n * properties on classes and links them.\n */\n@Component({name: 'implements'})\nexport class ImplementsPlugin extends ConverterComponent {\n    /**\n     * Create a new ImplementsPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, Converter.EVENT_RESOLVE, this.onResolve, -10);\n    }\n\n    /**\n     * Mark all members of the given class to be the implementation of the matching interface member.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param classReflection  The reflection of the classReflection class.\n     * @param interfaceReflection  The reflection of the interfaceReflection interface.\n     */\n    private analyzeClass(context: Context, classReflection: DeclarationReflection, interfaceReflection: DeclarationReflection) {\n        if (!interfaceReflection.children) {\n            return;\n        }\n\n        interfaceReflection.children.forEach((interfaceMember: DeclarationReflection) => {\n            if (!(interfaceMember instanceof DeclarationReflection)) {\n                return;\n            }\n\n            let classMember: DeclarationReflection;\n\n            if (!classReflection.children) {\n                return;\n            }\n\n            for (let index = 0, count = classReflection.children.length; index < count; index++) {\n                const child = classReflection.children[index];\n                if (child.name !== interfaceMember.name) {\n                    continue;\n                }\n                if (child.flags.isStatic !== interfaceMember.flags.isStatic) {\n                    continue;\n                }\n\n                classMember = child;\n                break;\n            }\n\n            if (!classMember) {\n                return;\n            }\n\n            const interfaceMemberName = interfaceReflection.name + '.' + interfaceMember.name;\n            classMember.implementationOf = new ReferenceType(interfaceMemberName, ReferenceType.SYMBOL_ID_RESOLVED, interfaceMember);\n            this.copyComment(classMember, interfaceMember);\n\n            if (interfaceMember.kindOf(ReflectionKind.FunctionOrMethod) && interfaceMember.signatures && classMember.signatures) {\n                interfaceMember.signatures.forEach((interfaceSignature: SignatureReflection) => {\n                    const interfaceParameters = interfaceSignature.getParameterTypes();\n                    classMember.signatures.forEach((classSignature: SignatureReflection) => {\n                        if (Type.isTypeListEqual(interfaceParameters, classSignature.getParameterTypes())) {\n                            classSignature.implementationOf = new ReferenceType(interfaceMemberName, ReferenceType.SYMBOL_ID_RESOLVED, interfaceSignature);\n                            this.copyComment(classSignature, interfaceSignature);\n                        }\n                    });\n                });\n            }\n        });\n    }\n\n    /**\n     * Copy the comment of the source reflection to the target reflection.\n     *\n     * @param target\n     * @param source\n     */\n    private copyComment(target: Reflection, source: Reflection) {\n        if (target.comment && source.comment && target.comment.hasTag('inheritdoc')) {\n            target.comment.copyFrom(source.comment);\n\n            if (target instanceof SignatureReflection && target.parameters &&\n                source instanceof SignatureReflection && source.parameters) {\n                for (let index = 0, count = target.parameters.length; index < count; index++) {\n                    if (target.parameters[index].comment) {\n                        target.parameters[index].comment.copyFrom(source.parameters[index].comment);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: DeclarationReflection) {\n        if (reflection.kindOf(ReflectionKind.Class) && reflection.implementedTypes) {\n            reflection.implementedTypes.forEach((type: Type) => {\n                if (!(type instanceof ReferenceType)) {\n                    return;\n                }\n\n                const source = <DeclarationReflection> (<ReferenceType> type).reflection;\n                if (source && source.kindOf(ReflectionKind.Interface)) {\n                    this.analyzeClass(context, reflection, source);\n                }\n            });\n        }\n    }\n}\n"]}