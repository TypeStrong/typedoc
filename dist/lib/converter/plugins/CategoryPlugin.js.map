{"version":3,"file":"CategoryPlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/CategoryPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ContainerReflection, DeclarationReflection } from '../../models';\nimport { ReflectionCategory } from '../../models/ReflectionCategory';\nimport { Component, ConverterComponent } from '../components';\nimport { Converter } from '../converter';\nimport { Context } from '../context';\nimport { Option } from '../../utils/component';\nimport { ParameterType } from '../../utils/options/declaration';\nimport { Comment } from '../../models/comments/index';\n\n/**\n * A handler that sorts and categorizes the found reflections in the resolving phase.\n *\n * The handler sets the ´category´ property of all reflections.\n */\n@Component({name: 'category'})\nexport class CategoryPlugin extends ConverterComponent {\n    @Option({\n        name: 'defaultCategory',\n        help: 'Specifies the default category for reflections without a category.',\n        type: ParameterType.String,\n        defaultValue: 'Other'\n    })\n    defaultCategory!: string;\n\n    @Option({\n        name: 'categoryOrder',\n        help: 'Specifies the order in which categories appear. * indicates the relative order for categories not in the list.',\n        type: ParameterType.Array\n    })\n    categoryOrder!: string[];\n\n    @Option({\n        name: 'categorizeByGroup',\n        help: 'Specifies whether categorization will be done at the group level.',\n        type: ParameterType.Boolean,\n        defaultValue: true\n    })\n    categorizeByGroup!: boolean;\n\n    // For use in static methods\n    static defaultCategory = 'Other';\n    static WEIGHTS: string[] = [];\n\n    /**\n     * Create a new CategoryPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [Converter.EVENT_BEGIN]:       this.onBegin,\n            [Converter.EVENT_RESOLVE]:     this.onResolve,\n            [Converter.EVENT_RESOLVE_END]: this.onEndResolve\n        }, undefined, -200);\n    }\n\n    /**\n     * Triggered when the converter begins converting a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onBegin(context: Context) {\n        // Set up static properties\n        if (this.defaultCategory) {\n            CategoryPlugin.defaultCategory = this.defaultCategory;\n        }\n        if (this.categoryOrder) {\n            CategoryPlugin.WEIGHTS = this.categoryOrder;\n        }\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: Reflection) {\n        if (reflection instanceof ContainerReflection) {\n            this.categorize(reflection);\n        }\n    }\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onEndResolve(context: Context) {\n        const project = context.project;\n        this.categorize(project);\n    }\n\n    private categorize(obj: ContainerReflection) {\n        if (this.categorizeByGroup) {\n            this.groupCategorize(obj);\n        } else {\n            this.lumpCategorize(obj);\n        }\n    }\n\n    private groupCategorize(obj: ContainerReflection) {\n        if (!obj.groups || obj.groups.length === 0) {\n            return;\n        }\n        obj.groups.forEach((group) => {\n            group.categories = CategoryPlugin.getReflectionCategories(group.children);\n            if (group.categories && group.categories.length > 1) {\n                group.categories.sort(CategoryPlugin.sortCatCallback);\n            } else if (group.categories.length === 1 && group.categories[0].title === CategoryPlugin.defaultCategory) {\n                // no categories if everything is uncategorized\n                group.categories = undefined;\n            }\n        });\n    }\n\n    private lumpCategorize(obj: ContainerReflection) {\n        if (obj instanceof ContainerReflection) {\n            if (obj.children && obj.children.length > 0) {\n                obj.categories = CategoryPlugin.getReflectionCategories(obj.children);\n            }\n            if (obj.categories && obj.categories.length > 1) {\n                obj.categories.sort(CategoryPlugin.sortCatCallback);\n            }\n        }\n    }\n\n    /**\n     * Create a categorized representation of the given list of reflections.\n     *\n     * @param reflections  The reflections that should be categorized.\n     * @returns An array containing all children of the given reflection categorized\n     */\n    static getReflectionCategories(reflections: Reflection[]): ReflectionCategory[] {\n        const categories: ReflectionCategory[] = [];\n        let defaultCat: ReflectionCategory | undefined;\n        reflections.forEach((child) => {\n            const childCat = CategoryPlugin.getCategory(child);\n            if (childCat === '') {\n                if (!defaultCat) {\n                    defaultCat = categories.find(category => category.title === CategoryPlugin.defaultCategory);\n                    if (!defaultCat) {\n                        defaultCat = new ReflectionCategory(CategoryPlugin.defaultCategory);\n                        categories.push(defaultCat);\n                    }\n                }\n                defaultCat.children.push(child);\n                return;\n            }\n            let category = categories.find(cat => cat.title === childCat);\n            if (category) {\n                category.children.push(child);\n                return;\n            }\n            category = new ReflectionCategory(childCat);\n            category.children.push(child);\n            categories.push(category);\n        });\n        return categories;\n    }\n\n    /**\n     * Return the category of a given reflection.\n     *\n     * @param reflection The reflection.\n     * @returns The category the reflection belongs to\n     */\n    static getCategory(reflection: Reflection): string {\n        function extractCategoryTag(comment: Comment) {\n            const tags = comment.tags;\n            if (tags) {\n                for (let i = 0; i < tags.length; i++) {\n                    if (tags[i].tagName === 'category') {\n                        let tag = tags[i].text;\n                        return tag.trim();\n                    }\n                }\n            }\n            return '';\n        }\n\n        let category = '';\n        if (reflection.comment) {\n            category = extractCategoryTag(reflection.comment);\n        } else if (reflection instanceof DeclarationReflection && reflection.signatures) {\n            // If a reflection has signatures, use the first category tag amongst them\n            reflection.signatures.forEach(sig => {\n                if (sig.comment && category === '') {\n                    category = extractCategoryTag(sig.comment);\n                }\n            });\n        }\n        return category;\n    }\n\n    /**\n     * Callback used to sort categories by name.\n     *\n     * @param a The left reflection to sort.\n     * @param b The right reflection to sort.\n     * @returns The sorting weight.\n     */\n    static sortCatCallback(a: ReflectionCategory, b: ReflectionCategory): number {\n        let aWeight = CategoryPlugin.WEIGHTS.indexOf(a.title);\n        let bWeight = CategoryPlugin.WEIGHTS.indexOf(b.title);\n        if (aWeight === -1 || bWeight === -1) {\n            let asteriskIndex = CategoryPlugin.WEIGHTS.indexOf('*');\n            if (asteriskIndex === -1) { asteriskIndex = CategoryPlugin.WEIGHTS.length; }\n            if (aWeight === -1) { aWeight = asteriskIndex; }\n            if (bWeight === -1) { bWeight = asteriskIndex; }\n        }\n        if (aWeight === bWeight) {\n            return a.title > b.title ? 1 : -1;\n        }\n        return aWeight - bWeight;\n    }\n}\n"]}