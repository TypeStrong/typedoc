{"version":3,"file":"TypePlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/TypePlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ReflectionKind, Decorator, DeclarationReflection, DeclarationHierarchy } from '../../models/reflections/index';\nimport { Type, ReferenceType, TupleType, UnionType, IntersectionType, ArrayType } from '../../models/types/index';\nimport { Component, ConverterComponent } from '../components';\nimport { Converter } from '../converter';\nimport { Context } from '../context';\n\n/**\n * A handler that converts all instances of [[LateResolvingType]] to their renderable equivalents.\n */\n@Component({name: 'type'})\nexport class TypePlugin extends ConverterComponent {\n    reflections: DeclarationReflection[] = [];\n\n    /**\n     * Create a new TypeHandler instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [Converter.EVENT_RESOLVE]:     this.onResolve,\n            [Converter.EVENT_RESOLVE_END]: this.onResolveEnd\n        });\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: DeclarationReflection) {\n        const project = context.project;\n\n        resolveType(reflection, <ReferenceType> reflection.type);\n        resolveType(reflection, <ReferenceType> reflection.inheritedFrom);\n        resolveType(reflection, <ReferenceType> reflection.overwrites);\n        resolveTypes(reflection, reflection.extendedTypes);\n        resolveTypes(reflection, reflection.extendedBy);\n        resolveTypes(reflection, reflection.implementedTypes);\n\n        if (reflection.decorators) {\n            reflection.decorators.forEach((decorator: Decorator) => {\n                if (decorator.type) {\n                    resolveType(reflection, decorator.type);\n                }\n            });\n        }\n\n        if (reflection.kindOf(ReflectionKind.ClassOrInterface)) {\n            this.postpone(reflection);\n\n            walk(reflection.implementedTypes, (target) => {\n                this.postpone(target);\n                if (!target.implementedBy) {\n                    target.implementedBy = [];\n                }\n                target.implementedBy.push(new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection));\n            });\n\n            walk(reflection.extendedTypes, (target) => {\n                this.postpone(target);\n                if (!target.extendedBy) {\n                    target.extendedBy = [];\n                }\n                target.extendedBy.push(new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection));\n            });\n        }\n\n        function walk(types: Type[], callback: {(declaration: DeclarationReflection): void}) {\n            if (!types) {\n                return;\n            }\n            types.forEach((type: ReferenceType) => {\n                if (!(type instanceof ReferenceType)) {\n                    return;\n                }\n                if (!type.reflection || !(type.reflection instanceof DeclarationReflection)) {\n                    return;\n                }\n                callback(<DeclarationReflection> type.reflection);\n            });\n        }\n\n        function resolveTypes(reflection: Reflection, types: Type[]) {\n            if (!types) {\n                return;\n            }\n            for (let i = 0, c = types.length; i < c; i++) {\n                resolveType(reflection, <ReferenceType> types[i]);\n            }\n        }\n\n        function resolveType(reflection: Reflection, type: Type) {\n            if (type instanceof ReferenceType) {\n                const referenceType: ReferenceType = <ReferenceType> type;\n                if (referenceType.symbolID === ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME) {\n                    referenceType.reflection = reflection.findReflectionByName(referenceType.name);\n                } else if (!referenceType.reflection && referenceType.symbolID !== ReferenceType.SYMBOL_ID_RESOLVED) {\n                    referenceType.reflection = project.reflections[project.symbolMapping[referenceType.symbolID]];\n                }\n\n                if (referenceType.typeArguments) {\n                    referenceType.typeArguments.forEach((typeArgument: Type) => {\n                        resolveType(reflection, typeArgument);\n                    });\n                }\n            } else if (type instanceof TupleType) {\n                const tupleType: TupleType = <TupleType> type;\n                for (let index = 0, count = tupleType.elements.length; index < count; index++) {\n                    resolveType(reflection, tupleType.elements[index]);\n                }\n            } else if (type instanceof UnionType || type instanceof IntersectionType) {\n                const unionOrIntersectionType: UnionType | IntersectionType = <UnionType | IntersectionType> type;\n                for (let index = 0, count = unionOrIntersectionType.types.length; index < count; index++) {\n                    resolveType(reflection, unionOrIntersectionType.types[index]);\n                }\n            } else if (type instanceof ArrayType) {\n                resolveType(reflection, type.elementType);\n            }\n        }\n    }\n\n    private postpone(reflection: DeclarationReflection) {\n        if (this.reflections.indexOf(reflection) === -1) {\n            this.reflections.push(reflection);\n        }\n    }\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onResolveEnd(context: Context) {\n        this.reflections.forEach((reflection) => {\n            if (reflection.implementedBy) {\n                reflection.implementedBy.sort((a: Type, b: Type): number => {\n                    if (a['name'] === b['name']) {\n                        return 0;\n                    }\n                    return a['name'] > b['name'] ? 1 : -1;\n                });\n            }\n\n            let root: DeclarationHierarchy;\n            let hierarchy: DeclarationHierarchy;\n            function push(types: Type[]) {\n                const level: DeclarationHierarchy = {types: types};\n                if (hierarchy) {\n                    hierarchy.next = level;\n                    hierarchy = level;\n                } else {\n                    root = hierarchy = level;\n                }\n            }\n\n            if (reflection.extendedTypes) {\n                push(reflection.extendedTypes);\n            }\n\n            push([new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection)]);\n            hierarchy.isTarget = true;\n\n            if (reflection.extendedBy) {\n                push(reflection.extendedBy);\n            }\n\n            reflection.typeHierarchy = root;\n        });\n    }\n}\n"]}