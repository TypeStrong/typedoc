{"version":3,"file":"TypePlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/TypePlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reflection, ReflectionKind, Decorator, DeclarationReflection, DeclarationHierarchy } from '../../models/reflections/index';\nimport { Type, ReferenceType, TupleType, UnionType, IntersectionType, ArrayType } from '../../models/types/index';\nimport { Component, ConverterComponent } from '../components';\nimport { Converter } from '../converter';\nimport { Context } from '../context';\n\n/**\n * A handler that converts all instances of [[LateResolvingType]] to their renderable equivalents.\n */\n@Component({name: 'type'})\nexport class TypePlugin extends ConverterComponent {\n    reflections: DeclarationReflection[] = [];\n\n    /**\n     * Create a new TypeHandler instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [Converter.EVENT_RESOLVE]:     this.onResolve,\n            [Converter.EVENT_RESOLVE_END]: this.onResolveEnd\n        });\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: DeclarationReflection) {\n        const project = context.project;\n\n        resolveType(reflection, <ReferenceType> reflection.type);\n        resolveType(reflection, <ReferenceType> reflection.inheritedFrom);\n        resolveType(reflection, <ReferenceType> reflection.overwrites);\n        resolveTypes(reflection, reflection.extendedTypes);\n        resolveTypes(reflection, reflection.extendedBy);\n        resolveTypes(reflection, reflection.implementedTypes);\n\n        if (reflection.decorators) {\n            reflection.decorators.forEach((decorator: Decorator) => {\n                if (decorator.type) {\n                    resolveType(reflection, decorator.type);\n                }\n            });\n        }\n\n        if (reflection.kindOf(ReflectionKind.ClassOrInterface)) {\n            this.postpone(reflection);\n\n            walk(reflection.implementedTypes, (target) => {\n                this.postpone(target);\n                if (!target.implementedBy) {\n                    target.implementedBy = [];\n                }\n                target.implementedBy.push(new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection));\n            });\n\n            walk(reflection.extendedTypes, (target) => {\n                this.postpone(target);\n                if (!target.extendedBy) {\n                    target.extendedBy = [];\n                }\n                target.extendedBy.push(new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection));\n            });\n        }\n\n        function walk(types: Type[] | undefined, callback: {(declaration: DeclarationReflection): void}) {\n            if (!types) {\n                return;\n            }\n            types.forEach(type => {\n                if (!(type instanceof ReferenceType)) {\n                    return;\n                }\n                if (!type.reflection || !(type.reflection instanceof DeclarationReflection)) {\n                    return;\n                }\n                callback(type.reflection);\n            });\n        }\n\n        function resolveTypes(reflection: Reflection, types?: Type[]) {\n            if (!types) {\n                return;\n            }\n            for (let i = 0, c = types.length; i < c; i++) {\n                resolveType(reflection, <ReferenceType> types[i]);\n            }\n        }\n\n        function resolveType(reflection: Reflection, type: Type) {\n            if (type instanceof ReferenceType) {\n                if (type.symbolID === ReferenceType.SYMBOL_ID_RESOLVE_BY_NAME) {\n                    type.reflection = reflection.findReflectionByName(type.name);\n                } else if (!type.reflection && type.symbolID !== ReferenceType.SYMBOL_ID_RESOLVED) {\n                    type.reflection = project.reflections[project.symbolMapping[type.symbolID]];\n                }\n\n                if (type.typeArguments) {\n                    resolveTypes(reflection, type.typeArguments);\n                }\n            } else if (type instanceof TupleType) {\n                resolveTypes(reflection, type.elements);\n            } else if (type instanceof UnionType || type instanceof IntersectionType) {\n                resolveTypes(reflection, type.types);\n            } else if (type instanceof ArrayType) {\n                resolveType(reflection, type.elementType);\n            }\n        }\n    }\n\n    private postpone(reflection: DeclarationReflection) {\n        if (!this.reflections.includes(reflection)) {\n            this.reflections.push(reflection);\n        }\n    }\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onResolveEnd(context: Context) {\n        this.reflections.forEach((reflection) => {\n            if (reflection.implementedBy) {\n                reflection.implementedBy.sort((a: Type, b: Type): number => {\n                    if (a['name'] === b['name']) {\n                        return 0;\n                    }\n                    return a['name'] > b['name'] ? 1 : -1;\n                });\n            }\n\n            let root!: DeclarationHierarchy;\n            let hierarchy!: DeclarationHierarchy;\n            function push(types: Type[]) {\n                const level: DeclarationHierarchy = {types: types};\n                if (hierarchy) {\n                    hierarchy.next = level;\n                    hierarchy = level;\n                } else {\n                    root = hierarchy = level;\n                }\n            }\n\n            if (reflection.extendedTypes) {\n                push(reflection.extendedTypes);\n            }\n\n            push([new ReferenceType(reflection.name, ReferenceType.SYMBOL_ID_RESOLVED, reflection)]);\n            hierarchy.isTarget = true;\n\n            if (reflection.extendedBy) {\n                push(reflection.extendedBy);\n            }\n\n            reflection.typeHierarchy = root;\n        });\n    }\n}\n"]}