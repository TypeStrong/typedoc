{"version":3,"file":"CommentPlugin.js","sourceRoot":"","sources":["../../../../src/lib/converter/plugins/CommentPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { Comment, CommentTag } from '../../models/comments/index';\nimport { IntrinsicType } from '../../models/types/index';\nimport { Reflection, ReflectionFlag, ReflectionKind, TraverseProperty,\n    TypeParameterReflection, DeclarationReflection, ProjectReflection,\n    SignatureReflection, ParameterReflection } from '../../models/reflections/index';\nimport { Component, ConverterComponent } from '../components';\nimport { parseComment, getRawComment } from '../factories/comment';\nimport { Converter } from '../converter';\nimport { Context } from '../context';\n\n/**\n * Structure used by [[ContainerCommentHandler]] to store discovered module comments.\n */\ninterface ModuleComment {\n    /**\n     * The module reflection this comment is targeting.\n     */\n    reflection: Reflection;\n\n    /**\n     * The full text of the best matched comment.\n     */\n    fullText: string;\n\n    /**\n     * Has the full text been marked as being preferred?\n     */\n    isPreferred: boolean;\n}\n\n/**\n * A handler that parses javadoc comments and attaches [[Models.Comment]] instances to\n * the generated reflections.\n */\n@Component({name: 'comment'})\nexport class CommentPlugin extends ConverterComponent {\n    /**\n     * List of discovered module comments.\n     * Defined in this.onBegin\n     */\n    private comments!: {[id: number]: ModuleComment};\n\n    /**\n     * List of hidden reflections.\n     */\n    private hidden?: Reflection[];\n\n    /**\n     * Create a new CommentPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [Converter.EVENT_BEGIN]:                   this.onBegin,\n            [Converter.EVENT_CREATE_DECLARATION]:      this.onDeclaration,\n            [Converter.EVENT_CREATE_SIGNATURE]:        this.onDeclaration,\n            [Converter.EVENT_CREATE_TYPE_PARAMETER]:   this.onCreateTypeParameter,\n            [Converter.EVENT_FUNCTION_IMPLEMENTATION]: this.onFunctionImplementation,\n            [Converter.EVENT_RESOLVE_BEGIN]:           this.onBeginResolve,\n            [Converter.EVENT_RESOLVE]:                 this.onResolve\n        });\n    }\n\n    private storeModuleComment(comment: string, reflection: Reflection) {\n        const isPreferred = (comment.toLowerCase().includes('@preferred'));\n\n        if (this.comments[reflection.id]) {\n            const info = this.comments[reflection.id];\n            if (!isPreferred && (info.isPreferred || info.fullText.length > comment.length)) {\n                return;\n            }\n\n            info.fullText    = comment;\n            info.isPreferred = isPreferred;\n        } else {\n            this.comments[reflection.id] = {\n                reflection:  reflection,\n                fullText:    comment,\n                isPreferred: isPreferred\n            };\n        }\n    }\n\n    /**\n     * Apply all comment tag modifiers to the given reflection.\n     *\n     * @param reflection  The reflection the modifiers should be applied to.\n     * @param comment  The comment that should be searched for modifiers.\n     */\n    private applyModifiers(reflection: Reflection, comment: Comment) {\n        if (comment.hasTag('private')) {\n            reflection.setFlag(ReflectionFlag.Private);\n            CommentPlugin.removeTags(comment, 'private');\n        }\n\n        if (comment.hasTag('protected')) {\n            reflection.setFlag(ReflectionFlag.Protected);\n            CommentPlugin.removeTags(comment, 'protected');\n        }\n\n        if (comment.hasTag('public')) {\n            reflection.setFlag(ReflectionFlag.Public);\n            CommentPlugin.removeTags(comment, 'public');\n        }\n\n        if (comment.hasTag('event')) {\n            reflection.kind = ReflectionKind.Event;\n            // reflection.setFlag(ReflectionFlag.Event);\n            CommentPlugin.removeTags(comment, 'event');\n        }\n\n        if (comment.hasTag('hidden') || comment.hasTag('ignore')) {\n            if (!this.hidden) {\n                this.hidden = [];\n            }\n            this.hidden.push(reflection);\n        }\n    }\n\n    /**\n     * Triggered when the converter begins converting a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onBegin(context: Context) {\n        this.hidden = undefined;\n        this.comments = {};\n    }\n\n    /**\n     * Triggered when the converter has created a type parameter reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    private onCreateTypeParameter(context: Context, reflection: TypeParameterReflection, node?: ts.Node) {\n        const comment = reflection.parent && reflection.parent.comment;\n        if (comment) {\n            let tag = comment.getTag('typeparam', reflection.name);\n            if (!tag) {\n                tag = comment.getTag('param', `<${reflection.name}>`);\n            }\n            if (!tag) {\n                tag = comment.getTag('param', reflection.name);\n            }\n\n            if (tag) {\n                reflection.comment = new Comment(tag.text);\n                // comment.tags must be set if we found a tag.\n                comment.tags!.splice(comment.tags!.indexOf(tag), 1);\n            }\n        }\n    }\n\n    /**\n     * Triggered when the converter has created a declaration or signature reflection.\n     *\n     * Invokes the comment parser.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    private onDeclaration(context: Context, reflection: Reflection, node?: ts.Node) {\n        if (!node) {\n            return;\n        }\n        const rawComment = getRawComment(node);\n        if (!rawComment) {\n            return;\n        }\n\n        if (reflection.kindOf(ReflectionKind.FunctionOrMethod) || (reflection.kindOf(ReflectionKind.Event) && reflection['signatures'])) {\n            const comment = parseComment(rawComment, reflection.comment);\n            this.applyModifiers(reflection, comment);\n        } else if (reflection.kindOf(ReflectionKind.Module)) {\n            this.storeModuleComment(rawComment, reflection);\n        } else {\n            const comment = parseComment(rawComment, reflection.comment);\n            this.applyModifiers(reflection, comment);\n            reflection.comment = comment;\n        }\n    }\n\n    /**\n     * Triggered when the converter has found a function implementation.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    private onFunctionImplementation(context: Context, reflection: Reflection, node?: ts.Node) {\n        if (!node) {\n            return;\n        }\n\n        const comment = getRawComment(node);\n        if (comment) {\n            reflection.comment = parseComment(comment, reflection.comment);\n        }\n    }\n\n    /**\n     * Triggered when the converter begins resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    private onBeginResolve(context: Context) {\n        for (let id in this.comments) {\n            if (!this.comments.hasOwnProperty(id)) {\n                continue;\n            }\n\n            const info    = this.comments[id];\n            const comment = parseComment(info.fullText);\n            CommentPlugin.removeTags(comment, 'preferred');\n\n            this.applyModifiers(info.reflection, comment);\n            info.reflection.comment = comment;\n        }\n\n        if (this.hidden) {\n            const project = context.project;\n            CommentPlugin.removeReflections(project, this.hidden);\n        }\n    }\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * Cleans up comment tags related to signatures like @param or @return\n     * and moves their data to the corresponding parameter reflections.\n     *\n     * This hook also copies over the comment of function implementations to their\n     * signatures.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    private onResolve(context: Context, reflection: DeclarationReflection) {\n        if (!(reflection instanceof DeclarationReflection)) {\n            return;\n        }\n\n        const signatures = reflection.getAllSignatures();\n        if (signatures.length) {\n            const comment = reflection.comment;\n            if (comment && comment.hasTag('returns')) {\n                comment.returns = comment.getTag('returns')!.text;\n                CommentPlugin.removeTags(comment, 'returns');\n            }\n\n            signatures.forEach((signature) => {\n                let childComment = signature.comment;\n                if (childComment && childComment.hasTag('returns')) {\n                    childComment.returns = childComment.getTag('returns')!.text;\n                    CommentPlugin.removeTags(childComment, 'returns');\n                }\n\n                if (comment) {\n                    if (!childComment) {\n                        childComment = signature.comment = new Comment();\n                    }\n\n                    childComment.shortText = childComment.shortText || comment.shortText;\n                    childComment.text      = childComment.text      || comment.text;\n                    childComment.returns   = childComment.returns   || comment.returns;\n                }\n\n                if (signature.parameters) {\n                    signature.parameters.forEach((parameter) => {\n                        let tag: CommentTag | undefined;\n                        if (childComment) {\n                            tag = childComment.getTag('param', parameter.name);\n                        }\n                        if (comment && !tag) {\n                            tag = comment.getTag('param', parameter.name);\n                        }\n                        if (tag) {\n                            parameter.comment = new Comment(tag.text);\n                        }\n                    });\n                }\n\n                CommentPlugin.removeTags(childComment, 'param');\n            });\n\n            CommentPlugin.removeTags(comment, 'param');\n        }\n    }\n\n    /**\n     * Remove all tags with the given name from the given comment instance.\n     *\n     * @param comment  The comment that should be modified.\n     * @param tagName  The name of the that that should be removed.\n     */\n    static removeTags(comment: Comment | undefined, tagName: string) {\n        if (!comment || !comment.tags) {\n            return;\n        }\n\n        let i = 0, c = comment.tags.length;\n        while (i < c) {\n            if (comment.tags[i].tagName === tagName) {\n                comment.tags.splice(i, 1);\n                c--;\n            } else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Remove the specified reflections from the project.\n     */\n    static removeReflections(project: ProjectReflection, reflections: Reflection[]) {\n        const deletedIds: number[] = [];\n        reflections.forEach((reflection) => {\n            CommentPlugin.removeReflection(project, reflection, deletedIds);\n        });\n\n        for (let key in project.symbolMapping) {\n            if (project.symbolMapping.hasOwnProperty(key) && deletedIds.includes(project.symbolMapping[key])) {\n                delete project.symbolMapping[key];\n            }\n        }\n    }\n\n    /**\n     * Remove the given reflection from the project.\n     */\n    static removeReflection(project: ProjectReflection, reflection: Reflection, deletedIds?: number[]) {\n        reflection.traverse((child) => CommentPlugin.removeReflection(project, child, deletedIds));\n\n        const parent = <DeclarationReflection> reflection.parent;\n        parent.traverse((child: Reflection, property: TraverseProperty) => {\n            if (child === reflection) {\n                switch (property) {\n                    case TraverseProperty.Children:\n                        if (parent.children) {\n                            const index = parent.children.indexOf(<DeclarationReflection> reflection);\n                            if (index !== -1) {\n                                parent.children.splice(index, 1);\n                            }\n                        }\n                        break;\n                    case TraverseProperty.GetSignature:\n                        delete parent.getSignature;\n                        break;\n                    case TraverseProperty.IndexSignature:\n                        delete parent.indexSignature;\n                        break;\n                    case TraverseProperty.Parameters:\n                        if ((<SignatureReflection> reflection.parent).parameters) {\n                            const index = (<SignatureReflection> reflection.parent).parameters!.indexOf(<ParameterReflection> reflection);\n                            if (index !== -1) {\n                                (<SignatureReflection> reflection.parent).parameters!.splice(index, 1);\n                            }\n                        }\n                        break;\n                    case TraverseProperty.SetSignature:\n                        delete parent.setSignature;\n                        break;\n                    case TraverseProperty.Signatures:\n                        if (parent.signatures) {\n                            const index = parent.signatures.indexOf(<SignatureReflection> reflection);\n                            if (index !== -1) {\n                                parent.signatures.splice(index, 1);\n                            }\n                        }\n                        break;\n                    case TraverseProperty.TypeLiteral:\n                        parent.type = new IntrinsicType('Object');\n                        break;\n                    case TraverseProperty.TypeParameter:\n                        if (parent.typeParameters) {\n                            const index = parent.typeParameters.indexOf(<TypeParameterReflection> reflection);\n                            if (index !== -1) {\n                                parent.typeParameters.splice(index, 1);\n                            }\n                        }\n                        break;\n                }\n            }\n        });\n\n        let id = reflection.id;\n        delete project.reflections[id];\n\n        // if an array was provided, keep track of the reflections that have been deleted, otherwise clean symbol mappings\n        if (deletedIds) {\n            deletedIds.push(id);\n        } else {\n            for (let key in project.symbolMapping) {\n                if (project.symbolMapping.hasOwnProperty(key) && project.symbolMapping[key] === id) {\n                    delete project.symbolMapping[key];\n                }\n            }\n        }\n\n    }\n}\n"]}