{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/signature.ts"],"names":[],"mappings":";;AAAA,iCAAiC;AAEjC,8CAA2H;AAE3H,4CAAyC;AACzC,2CAA8C;AAC9C,2CAAkD;AAWlD,SAAgB,eAAe,CAAC,OAAgB,EAAE,IAA6B,EAAE,IAAY,EAAE,IAAoB;IAC/G,MAAM,SAAS,GAA2B,OAAO,CAAC,KAAK,CAAC;IACxD,IAAI,CAAC,CAAC,SAAS,YAAY,2BAAmB,CAAC,EAAE;QAC7C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;KACrD;IAED,MAAM,SAAS,GAAG,IAAI,2BAAmB,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;IACjE,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,GAAG,EAAE;QACzD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAkC,EAAE,EAAE;YAC3D,2BAAe,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC,IAAI,GAAG,oBAAoB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAErD,IAAI,SAAS,CAAC,aAAa,EAAE;YACzB,SAAS,CAAC,aAAa,GAAG,+BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC7E;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,sBAAsB,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACnE,OAAO,SAAS,CAAC;AACrB,CAAC;AAtBD,0CAsBC;AASD,SAAS,oBAAoB,CAAC,OAAgB,EAAE,IAA6B;IACzE,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,cAAc,EAAE;QACrF,IAAI;YACA,MAAM,SAAS,GAAG,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;YAE5D,IAAI,CAAC,SAAS,EAAE;gBACZ,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;aAC7D;YACD,OAAO,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC,CAAC;SACzG;QAAC,OAAO,KAAK,EAAE,GAAE;KACrB;IAED,OAAO,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC;AACrE,CAAC","sourcesContent":["import * as ts from 'typescript';\n\nimport { ReflectionKind, SignatureReflection, ContainerReflection, DeclarationReflection, Type } from '../../models/index';\nimport { Context } from '../context';\nimport { Converter } from '../converter';\nimport { createParameter } from './parameter';\nimport { createReferenceType } from './reference';\n\n/**\n * Create a new signature reflection from the given node.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The TypeScript node containing the signature declaration that should be reflected.\n * @param name  The name of the function or method this signature belongs to.\n * @param kind  The desired kind of the reflection.\n * @returns The newly created signature reflection describing the given node.\n */\nexport function createSignature(context: Context, node: ts.SignatureDeclaration, name: string, kind: ReflectionKind): SignatureReflection {\n    const container = <DeclarationReflection> context.scope;\n    if (!(container instanceof ContainerReflection)) {\n        throw new Error('Expected container reflection.');\n    }\n\n    const signature = new SignatureReflection(name, kind, container);\n    context.registerReflection(signature, node);\n    context.withScope(signature, node.typeParameters, true, () => {\n        node.parameters.forEach((parameter: ts.ParameterDeclaration) => {\n            createParameter(context, parameter);\n        });\n\n        signature.type = extractSignatureType(context, node);\n\n        if (container.inheritedFrom) {\n            signature.inheritedFrom = createReferenceType(context, node.symbol, true);\n        }\n    });\n\n    context.trigger(Converter.EVENT_CREATE_SIGNATURE, signature, node);\n    return signature;\n}\n\n/**\n * Extract the return type of the given signature declaration.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The signature declaration whose return type should be determined.\n * @returns The return type reflection of the given signature.\n */\nfunction extractSignatureType(context: Context, node: ts.SignatureDeclaration): Type | undefined {\n    const checker = context.checker;\n    if (node.kind & ts.SyntaxKind.CallSignature || node.kind & ts.SyntaxKind.CallExpression) {\n        try {\n            const signature = checker.getSignatureFromDeclaration(node);\n            // This is essentially what checker.getReturnTypeOfSignature will do, but doing it ourselves avoids type errors.\n            if (!signature) {\n                throw new Error('Failed to retrieve signature for node.');\n            }\n            return context.converter.convertType(context, node.type, checker.getReturnTypeOfSignature(signature));\n        } catch (error) {}\n    }\n\n    return context.converter.convertType(context, node.type || node);\n}\n"]}