{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/signature.ts"],"names":[],"mappings":";;AAAA,+BAAiC;AAEjC,4CAA2H;AAE3H,0CAAyC;AACzC,yCAA8C;AAC9C,yCAAkD;AAWlD,yBAAgC,OAAgB,EAAE,IAA6B,EAAE,IAAY,EAAE,IAAoB;IAC/G,IAAM,SAAS,GAA2B,OAAO,CAAC,KAAK,CAAC;IACxD,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,YAAY,2BAAmB,CAAC,CAAC,CAAC,CAAC;QAC9C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAED,IAAM,SAAS,GAAG,IAAI,2BAAmB,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IACjE,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE;QACpD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,SAAkC;YACvD,2BAAe,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC,IAAI,GAAG,oBAAoB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAErD,EAAE,CAAC,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;YAC1B,SAAS,CAAC,aAAa,GAAG,+BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC9E,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,sBAAsB,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACnE,MAAM,CAAC,SAAS,CAAC;AACrB,CAAC;AAtBD,0CAsBC;AASD,8BAA8B,OAAgB,EAAE,IAA6B;IACzE,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC;QACtF,IAAI,CAAC;YACD,IAAM,SAAS,GAAG,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;YAC5D,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1G,CAAC;QAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA,CAAC;IACtB,CAAC;IAED,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACZ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7D,CAAC;IAAC,IAAI,CAAC,CAAC;QACJ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACxD,CAAC;AACL,CAAC","sourcesContent":["import * as ts from 'typescript';\n\nimport { ReflectionKind, SignatureReflection, ContainerReflection, DeclarationReflection, Type } from '../../models/index';\nimport { Context } from '../context';\nimport { Converter } from '../converter';\nimport { createParameter } from './parameter';\nimport { createReferenceType } from './reference';\n\n/**\n * Create a new signature reflection from the given node.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The TypeScript node containing the signature declaration that should be reflected.\n * @param name  The name of the function or method this signature belongs to.\n * @param kind  The desired kind of the reflection.\n * @returns The newly created signature reflection describing the given node.\n */\nexport function createSignature(context: Context, node: ts.SignatureDeclaration, name: string, kind: ReflectionKind): SignatureReflection {\n    const container = <DeclarationReflection> context.scope;\n    if (!(container instanceof ContainerReflection)) {\n        throw new Error('Expected container reflection.');\n    }\n\n    const signature = new SignatureReflection(container, name, kind);\n    context.registerReflection(signature, node);\n    context.withScope(signature, node.typeParameters, true, () => {\n        node.parameters.forEach((parameter: ts.ParameterDeclaration) => {\n            createParameter(context, parameter);\n        });\n\n        signature.type = extractSignatureType(context, node);\n\n        if (container.inheritedFrom) {\n            signature.inheritedFrom = createReferenceType(context, node.symbol, true);\n        }\n    });\n\n    context.trigger(Converter.EVENT_CREATE_SIGNATURE, signature, node);\n    return signature;\n}\n\n/**\n * Extract the return type of the given signature declaration.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The signature declaration whose return type should be determined.\n * @returns The return type reflection of the given signature.\n */\nfunction extractSignatureType(context: Context, node: ts.SignatureDeclaration): Type {\n    const checker = context.checker;\n    if (node.kind & ts.SyntaxKind.CallSignature || node.kind & ts.SyntaxKind.CallExpression) {\n        try {\n            const signature = checker.getSignatureFromDeclaration(node);\n            return context.converter.convertType(context, node.type, checker.getReturnTypeOfSignature(signature));\n        } catch (error) {}\n    }\n\n    if (node.type) {\n        return context.converter.convertType(context, node.type);\n    } else {\n        return context.converter.convertType(context, node);\n    }\n}\n"]}