{"version":3,"file":"comment.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/comment.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport * as _ts from '../../ts-internal';\n\nimport { Comment, CommentTag } from '../../models/comments/index';\n\n/**\n * Return the parsed comment of the given TypeScript node.\n *\n * @param node  The node whose comment should be returned.\n * @return The parsed comment as a [[Comment]] instance or NULL if\n *     no comment is present.\n */\nexport function createComment(node: ts.Node): Comment {\n    const comment = getRawComment(node);\n    if (comment == null) {\n        return null;\n    }\n\n    return parseComment(comment);\n}\n\n/**\n * Check whether the given module declaration is the topmost.\n *\n * This funtion returns TRUE if there is no trailing module defined, in\n * the following example this would be the case only for module <code>C</code>.\n *\n * ```\n * module A.B.C { }\n * ```\n *\n * @param node  The module definition that should be tested.\n * @return TRUE if the given node is the topmost module declaration, FALSE otherwise.\n */\nfunction isTopmostModuleDeclaration(node: ts.ModuleDeclaration): boolean {\n    if (node.nextContainer && node.nextContainer.kind === ts.SyntaxKind.ModuleDeclaration) {\n        let next = <ts.ModuleDeclaration> node.nextContainer;\n        if (node.name.end + 1 === next.name.pos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Return the root module declaration of the given module declaration.\n *\n * In the following example this function would always return module\n * <code>A</code> no matter which of the modules was passed in.\n *\n * ```\n * module A.B.C { }\n * ```\n */\nfunction getRootModuleDeclaration(node: ts.ModuleDeclaration): ts.Node {\n    while (node.parent && node.parent.kind === ts.SyntaxKind.ModuleDeclaration) {\n        let parent = <ts.ModuleDeclaration> node.parent;\n        if (node.name.pos === parent.name.end + 1) {\n            node = parent;\n        } else {\n            break;\n        }\n    }\n\n    return node;\n}\n\n/**\n * Return the raw comment string for the given node.\n *\n * @param node  The node whose comment should be resolved.\n * @returns     The raw comment string or NULL if no comment could be found.\n */\nexport function getRawComment(node: ts.Node): string {\n    if (node.parent && node.parent.kind === ts.SyntaxKind.VariableDeclarationList) {\n        node = node.parent.parent;\n    } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        if (!isTopmostModuleDeclaration(<ts.ModuleDeclaration> node)) {\n            return null;\n        } else {\n            node = getRootModuleDeclaration(<ts.ModuleDeclaration> node);\n        }\n    }\n\n    const sourceFile = _ts.getSourceFileOfNode(node);\n    const comments = _ts.getJSDocCommentRanges(node, sourceFile.text);\n    if (comments && comments.length) {\n        let comment: ts.CommentRange;\n        if (node.kind === ts.SyntaxKind.SourceFile) {\n            if (comments.length === 1) {\n                return null;\n            }\n            comment = comments[0];\n        } else {\n            comment = comments[comments.length - 1];\n        }\n\n        return sourceFile.text.substring(comment.pos, comment.end);\n    } else {\n        return null;\n    }\n}\n\n/**\n * Parse the given doc comment string.\n *\n * @param text     The doc comment string that should be parsed.\n * @param comment  The [[Models.Comment]] instance the parsed results should be stored into.\n * @returns        A populated [[Models.Comment]] instance.\n */\nexport function parseComment(text: string, comment: Comment = new Comment()): Comment {\n    let currentTag: CommentTag;\n    let shortText = 0;\n\n    function consumeTypeData(line: string): string {\n        line = line.replace(/^\\{[^\\}]*\\}+/, '');\n        line = line.replace(/^\\[[^\\[][^\\]]*\\]+/, '');\n        return line.trim();\n    }\n\n    function readBareLine(line: string) {\n        if (currentTag) {\n            currentTag.text += '\\n' + line;\n        } else if (line === '' && shortText === 0) {\n            // Ignore\n        } else if (line === '' && shortText === 1) {\n            shortText = 2;\n        } else {\n            if (shortText === 2) {\n                comment.text += (comment.text === '' ? '' : '\\n') + line;\n            } else {\n                comment.shortText += (comment.shortText === '' ? '' : '\\n') + line;\n                shortText = 1;\n            }\n        }\n    }\n\n    function readTagLine(line: string, tag: RegExpExecArray) {\n        let tagName = tag[1].toLowerCase();\n        let paramName: string;\n        line = line.substr(tagName.length + 1).trim();\n\n        if (tagName === 'return') { tagName = 'returns'; }\n        if (tagName === 'param' || tagName === 'typeparam') {\n            line = consumeTypeData(line);\n            const param = /[^\\s]+/.exec(line);\n            if (param) {\n                paramName = param[0];\n                line = line.substr(paramName.length + 1).trim();\n            }\n            line = consumeTypeData(line);\n            line = line.replace(/^\\-\\s+/, '');\n        } else if (tagName === 'returns') {\n            line = consumeTypeData(line);\n        }\n\n        currentTag = new CommentTag(tagName, paramName, line);\n        if (!comment.tags) { comment.tags = []; }\n        comment.tags.push(currentTag);\n    }\n\n    const CODE_FENCE = /^\\s*```(?!.*```)/;\n    let inCode = false;\n    function readLine(line: string) {\n        line = line.replace(/^\\s*\\*? ?/, '');\n        line = line.replace(/\\s*$/, '');\n\n        if (CODE_FENCE.test(line) ) {\n          inCode = !inCode;\n        }\n\n        if (!inCode) {\n          const tag = /^@(\\S+)/.exec(line);\n          if (tag) {\n            return readTagLine(line, tag);\n          }\n        }\n        readBareLine(line);\n    }\n\n    // text = text.replace(/^\\s*\\/\\*+\\s*(\\r\\n?|\\n)/, '');\n    // text = text.replace(/(\\r\\n?|\\n)\\s*\\*+\\/\\s*$/, '');\n    text = text.replace(/^\\s*\\/\\*+/, '');\n    text = text.replace(/\\*+\\/\\s*$/, '');\n    text.split(/\\r\\n?|\\n/).forEach(readLine);\n\n    return comment;\n}\n"]}