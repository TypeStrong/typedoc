{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/lib/converter/context.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport { Minimatch, IMinimatch } from 'minimatch';\n\nimport { Logger } from '../utils/loggers';\nimport { Reflection, ProjectReflection, ContainerReflection, Type } from '../models/index';\nimport { createTypeParameter } from './factories/type-parameter';\nimport { Converter } from './converter';\n\n/**\n * The context describes the current state the converter is in.\n */\nexport class Context {\n    /**\n     * The converter instance that has created the context.\n     */\n    converter: Converter;\n\n    /**\n     * A list of all files that have been passed to the TypeScript compiler.\n     */\n    fileNames: string[];\n\n    /**\n     * The TypeChecker instance returned by the TypeScript compiler.\n     */\n    checker: ts.TypeChecker;\n\n    /**\n     * The program that is currently processed.\n     */\n    program: ts.Program;\n\n    /**\n     * The project that is currently processed.\n     */\n    project: ProjectReflection;\n\n    /**\n     * The scope or parent reflection that is currently processed.\n     */\n    scope: Reflection;\n\n    /**\n     * Is the current source file marked as being external?\n     */\n    isExternal: boolean;\n\n    /**\n     * Is the current source file a declaration file?\n     */\n    isDeclaration: boolean;\n\n    /**\n     * The currently set type parameters.\n     */\n    typeParameters: ts.MapLike<Type>;\n\n    /**\n     * The currently set type arguments.\n     */\n    typeArguments: Type[];\n\n    /**\n     * Is the converter in inheritance mode?\n     */\n    isInherit: boolean;\n\n    /**\n     * The node that has started the inheritance mode.\n     */\n    inheritParent: ts.Node;\n\n    /**\n     * List symbol ids of inherited children already visited while inheriting.\n     */\n    inheritedChildren: number[];\n\n    /**\n     * The names of the children of the scope before inheritance has been started.\n     */\n    inherited: string[];\n\n    /**\n     * A list of parent nodes that have been passed to the visit function.\n     */\n    visitStack: ts.Node[];\n\n    /**\n     * Next free symbol id used by [[getSymbolID]].\n     */\n    private symbolID = -1024;\n\n    /**\n     * The pattern that should be used to flag external source files.\n     */\n    private externalPattern: IMinimatch;\n\n    /**\n     * Create a new Context instance.\n     *\n     * @param converter  The converter instance that has created the context.\n     * @param fileNames  A list of all files that have been passed to the TypeScript compiler.\n     * @param checker  The TypeChecker instance returned by the TypeScript compiler.\n     */\n    constructor(converter: Converter, fileNames: string[], checker: ts.TypeChecker, program: ts.Program) {\n        this.converter = converter;\n        this.fileNames = fileNames;\n        this.checker = checker;\n        this.program = program;\n        this.visitStack = [];\n\n        const project = new ProjectReflection(converter.name);\n        this.project = project;\n        this.scope = project;\n\n        if (converter.externalPattern) {\n            this.externalPattern = new Minimatch(converter.externalPattern);\n        }\n    }\n\n    /**\n     * Return the compiler options.\n     */\n    getCompilerOptions(): ts.CompilerOptions {\n        return this.converter.application.options.getCompilerOptions();\n    }\n\n    /**\n     * Return the type declaration of the given node.\n     *\n     * @param node  The TypeScript node whose type should be resolved.\n     * @returns The type declaration of the given node.\n     */\n    getTypeAtLocation(node: ts.Node): ts.Type {\n        let nodeType: ts.Type;\n        try {\n            nodeType = this.checker.getTypeAtLocation(node);\n        } catch (error) {\n        }\n        if (!nodeType) {\n            if (node.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.symbol);\n            } else if (node.parent && node.parent.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.parent.symbol);\n            } else if (node.parent && node.parent.parent && node.parent.parent.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.parent.parent.symbol);\n            }\n        }\n        return nodeType;\n    }\n\n    /**\n     * Return the current logger instance.\n     *\n     * @returns The current logger instance.\n     */\n    getLogger(): Logger {\n        return this.converter.application.logger;\n    }\n\n    /**\n     * Return the symbol id of the given symbol.\n     *\n     * The compiler sometimes does not assign an id to symbols, this method makes sure that we have one.\n     * It will assign negative ids if they are not set.\n     *\n     * @param symbol  The symbol whose id should be returned.\n     * @returns The id of the given symbol.\n     */\n    getSymbolID(symbol: ts.Symbol): number {\n        if (!symbol) {\n            return null;\n        }\n        if (!symbol.id) {\n            symbol.id = this.symbolID--;\n        }\n        return symbol.id;\n    }\n\n    /**\n     * Register a newly generated reflection.\n     *\n     * Ensures that the reflection is both listed in [[Project.reflections]] and\n     * [[Project.symbolMapping]] if applicable.\n     *\n     * @param reflection  The reflection that should be registered.\n     * @param node  The node the given reflection was resolved from.\n     * @param symbol  The symbol the given reflection was resolved from.\n     */\n    registerReflection(reflection: Reflection, node: ts.Node, symbol?: ts.Symbol) {\n        this.project.reflections[reflection.id] = reflection;\n\n        const id = this.getSymbolID(symbol ? symbol : (node ? node.symbol : null));\n        if (!this.isInherit && id && !this.project.symbolMapping[id]) {\n            this.project.symbolMapping[id] = reflection.id;\n        }\n    }\n\n    /**\n     * Trigger a node reflection event.\n     *\n     * All events are dispatched on the current converter instance.\n     *\n     * @param name  The name of the event that should be triggered.\n     * @param reflection  The triggering reflection.\n     * @param node  The triggering TypeScript node if available.\n     */\n    trigger(name: string, reflection: Reflection, node?: ts.Node) {\n        this.converter.trigger(name, this, reflection, node);\n    }\n\n    /**\n     * Run the given callback with the context configured for the given source file.\n     *\n     * @param node  The TypeScript node containing the source file declaration.\n     * @param callback  The callback that should be executed.\n     */\n    withSourceFile(node: ts.SourceFile, callback: Function) {\n        const externalPattern = this.externalPattern;\n        let isExternal = this.fileNames.indexOf(node.fileName) === -1;\n        if (externalPattern) {\n            isExternal = isExternal || externalPattern.match(node.fileName);\n        }\n\n        if (isExternal && this.converter.excludeExternals) {\n            return;\n        }\n\n        let isDeclaration = node.isDeclarationFile;\n        if (isDeclaration) {\n            const lib = this.converter.getDefaultLib();\n            const isLib = node.fileName.substr(-lib.length) === lib;\n            if (!this.converter.includeDeclarations || isLib) {\n                return;\n            }\n        }\n\n        this.isExternal = isExternal;\n        this.isDeclaration = isDeclaration;\n\n        this.trigger(Converter.EVENT_FILE_BEGIN, this.project, node);\n        callback();\n\n        this.isExternal = false;\n        this.isDeclaration = false;\n    }\n\n    /**\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope: Reflection, callback: Function): void;\n\n    /**\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope: Reflection, parameters: ts.NodeArray<ts.TypeParameterDeclaration>, callback: Function): void;\n\n    /**\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\n     * @param preserve  Should the currently set type parameters of the context be preserved?\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope: Reflection, parameters: ts.NodeArray<ts.TypeParameterDeclaration>, preserve: boolean, callback: Function): void;\n\n    /**\n     * Run the given callback with the scope of the context set to the given reflection.\n     *\n     * @param scope  The reflection that should be set as the scope of the context while the callback is invoked.\n     */\n    public withScope(scope: Reflection, ...args: any[]): void {\n        if (!scope || !args.length) {\n            return;\n        }\n        const callback = args.pop();\n        const parameters = args.shift();\n\n        const oldScope = this.scope;\n        const oldTypeArguments = this.typeArguments;\n        const oldTypeParameters = this.typeParameters;\n\n        this.scope = scope;\n        this.typeParameters = parameters ? this.extractTypeParameters(parameters, args.length > 0) : this.typeParameters;\n        this.typeArguments = null;\n\n        callback();\n\n        this.scope = oldScope;\n        this.typeParameters = oldTypeParameters;\n        this.typeArguments = oldTypeArguments;\n    }\n\n    /**\n     * Inherit the children of the given TypeScript node to the current scope.\n     *\n     * @param baseNode  The node whose children should be inherited.\n     * @param typeArguments  The type arguments that apply while inheriting the given node.\n     * @return The resulting reflection / the current scope.\n     */\n    inherit(baseNode: ts.Node, typeArguments?: ts.NodeArray<ts.TypeNode>): Reflection {\n        const wasInherit = this.isInherit;\n        const oldInherited = this.inherited;\n        const oldInheritParent = this.inheritParent;\n        const oldTypeArguments = this.typeArguments;\n\n        this.isInherit = true;\n        this.inheritParent = baseNode;\n        this.inherited = [];\n\n        const target = <ContainerReflection> this.scope;\n        if (!(target instanceof ContainerReflection)) {\n            throw new Error('Expected container reflection');\n        }\n\n        if (baseNode.symbol) {\n            const id = this.getSymbolID(baseNode.symbol);\n            if (this.inheritedChildren && this.inheritedChildren.indexOf(id) !== -1) {\n                return target;\n            } else {\n                this.inheritedChildren = this.inheritedChildren || [];\n                this.inheritedChildren.push(id);\n            }\n        }\n\n        if (target.children) {\n            this.inherited = target.children.map((c) => c.name);\n        } else {\n            this.inherited = [];\n        }\n\n        if (typeArguments) {\n            this.typeArguments = typeArguments.map((t) => this.converter.convertType(this, t));\n        } else {\n            this.typeArguments = null;\n        }\n\n        this.converter.convertNode(this, baseNode);\n\n        this.isInherit = wasInherit;\n        this.inherited = oldInherited;\n        this.inheritParent = oldInheritParent;\n        this.typeArguments = oldTypeArguments;\n\n        if (!this.isInherit) {\n            delete this.inheritedChildren;\n        }\n\n        return target;\n    }\n\n    /**\n     * Convert the given list of type parameter declarations into a type mapping.\n     *\n     * @param parameters  The list of type parameter declarations that should be converted.\n     * @param preserve  Should the currently set type parameters of the context be preserved?\n     * @returns The resulting type mapping.\n     */\n    private extractTypeParameters(parameters: ts.NodeArray<ts.TypeParameterDeclaration>, preserve?: boolean): ts.MapLike<Type> {\n        const typeParameters: ts.MapLike<Type> = {};\n\n        if (preserve) {\n            for (let key in this.typeParameters) {\n                if (!this.typeParameters.hasOwnProperty(key)) {\n                    continue;\n                }\n                typeParameters[key] = this.typeParameters[key];\n            }\n        }\n\n        parameters.forEach((declaration: ts.TypeParameterDeclaration, index: number) => {\n            const name = declaration.symbol.name;\n            if (this.typeArguments && this.typeArguments[index]) {\n                typeParameters[name] = this.typeArguments[index];\n            } else {\n                typeParameters[name] = createTypeParameter(this, declaration);\n            }\n        });\n\n        return typeParameters;\n    }\n}\n"]}