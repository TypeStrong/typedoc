{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/lib/converter/context.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport { IMinimatch } from 'minimatch';\n\nimport { Logger } from '../utils/loggers';\nimport { createMinimatch } from '../utils/paths';\nimport { Reflection, ProjectReflection, ContainerReflection, Type } from '../models/index';\n\nimport { createTypeParameter } from './factories/type-parameter';\nimport { Converter } from './converter';\n\n/**\n * The context describes the current state the converter is in.\n */\nexport class Context {\n    /**\n     * The converter instance that has created the context.\n     */\n    converter: Converter;\n\n    /**\n     * A list of all files that have been passed to the TypeScript compiler.\n     */\n    fileNames: string[];\n\n    /**\n     * The TypeChecker instance returned by the TypeScript compiler.\n     */\n    checker: ts.TypeChecker;\n\n    /**\n     * The program that is currently processed.\n     */\n    program: ts.Program;\n\n    /**\n     * The project that is currently processed.\n     */\n    project: ProjectReflection;\n\n    /**\n     * The scope or parent reflection that is currently processed.\n     */\n    scope: Reflection;\n\n    /**\n     * Is the current source file marked as being external?\n     */\n    isExternal?: boolean;\n\n    /**\n     * Is the current source file a declaration file?\n     */\n    isDeclaration?: boolean;\n\n    /**\n     * The currently set type parameters.\n     */\n    typeParameters?: ts.MapLike<Type>;\n\n    /**\n     * The currently set type arguments.\n     */\n    typeArguments?: Type[];\n\n    /**\n     * Is the converter in inheritance mode?\n     */\n    isInherit?: boolean;\n\n    /**\n     * The node that has started the inheritance mode.\n     */\n    inheritParent?: ts.Node;\n\n    /**\n     * List symbol ids of inherited children already visited while inheriting.\n     */\n    inheritedChildren?: number[];\n\n    /**\n     * The names of the children of the scope before inheritance has been started.\n     */\n    inherited?: string[];\n\n    /**\n     * A list of parent nodes that have been passed to the visit function.\n     */\n    visitStack: ts.Node[];\n\n    /**\n     * Next free symbol id used by [[getSymbolID]].\n     */\n    private symbolID = -1024;\n\n    /**\n     * The pattern that should be used to flag external source files.\n     */\n    private externalPattern?: Array<IMinimatch>;\n\n    /**\n     * Create a new Context instance.\n     *\n     * @param converter  The converter instance that has created the context.\n     * @param fileNames  A list of all files that have been passed to the TypeScript compiler.\n     * @param checker  The TypeChecker instance returned by the TypeScript compiler.\n     */\n    constructor(converter: Converter, fileNames: string[], checker: ts.TypeChecker, program: ts.Program) {\n        this.converter = converter;\n        this.fileNames = fileNames;\n        this.checker = checker;\n        this.program = program;\n        this.visitStack = [];\n\n        const project = new ProjectReflection(converter.name);\n        this.project = project;\n        this.scope = project;\n\n        if (converter.externalPattern) {\n            this.externalPattern = createMinimatch(converter.externalPattern);\n        }\n    }\n\n    /**\n     * Return the compiler options.\n     */\n    getCompilerOptions(): ts.CompilerOptions {\n        return this.converter.application.options.getCompilerOptions();\n    }\n\n    /**\n     * Return the type declaration of the given node.\n     *\n     * @param node  The TypeScript node whose type should be resolved.\n     * @returns The type declaration of the given node.\n     */\n    getTypeAtLocation(node: ts.Node): ts.Type | undefined {\n        let nodeType: ts.Type | undefined;\n        try {\n            nodeType = this.checker.getTypeAtLocation(node);\n        } catch (error) {\n        }\n        if (!nodeType) {\n            if (node.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.symbol);\n            } else if (node.parent && node.parent.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.parent.symbol);\n            } else if (node.parent && node.parent.parent && node.parent.parent.symbol) {\n                nodeType = this.checker.getDeclaredTypeOfSymbol(node.parent.parent.symbol);\n            }\n        }\n        return nodeType;\n    }\n\n    /**\n     * Return the current logger instance.\n     *\n     * @returns The current logger instance.\n     */\n    getLogger(): Logger {\n        return this.converter.application.logger;\n    }\n\n    /**\n     * Return the symbol id of the given symbol.\n     *\n     * The compiler sometimes does not assign an id to symbols, this method makes sure that we have one.\n     * It will assign negative ids if they are not set.\n     *\n     * @param symbol  The symbol whose id should be returned.\n     * @returns The id of the given symbol or undefined if no symbol is provided.\n     */\n    getSymbolID(symbol: ts.Symbol | undefined): number | undefined {\n        if (!symbol) {\n            return;\n        }\n        if (!symbol.id) {\n            symbol.id = this.symbolID--;\n        }\n        return symbol.id;\n    }\n\n    /**\n     * Register a newly generated reflection.\n     *\n     * Ensures that the reflection is both listed in [[Project.reflections]] and\n     * [[Project.symbolMapping]] if applicable.\n     *\n     * @param reflection  The reflection that should be registered.\n     * @param node  The node the given reflection was resolved from.\n     * @param symbol  The symbol the given reflection was resolved from.\n     */\n    registerReflection(reflection: Reflection, node?: ts.Node, symbol?: ts.Symbol) {\n        this.project.reflections[reflection.id] = reflection;\n\n        const id = this.getSymbolID(symbol ? symbol : (node ? node.symbol : undefined));\n        if (!this.isInherit && id && !this.project.symbolMapping[id]) {\n            this.project.symbolMapping[id] = reflection.id;\n        }\n    }\n\n    /**\n     * Trigger a node reflection event.\n     *\n     * All events are dispatched on the current converter instance.\n     *\n     * @param name  The name of the event that should be triggered.\n     * @param reflection  The triggering reflection.\n     * @param node  The triggering TypeScript node if available.\n     */\n    trigger(name: string, reflection: Reflection, node?: ts.Node) {\n        this.converter.trigger(name, this, reflection, node);\n    }\n\n    /**\n     * Run the given callback with the context configured for the given source file.\n     *\n     * @param node  The TypeScript node containing the source file declaration.\n     * @param callback  The callback that should be executed.\n     */\n    withSourceFile(node: ts.SourceFile, callback: Function) {\n        let isExternal = !this.fileNames.includes(node.fileName);\n        if (!isExternal && this.externalPattern) {\n            isExternal = this.externalPattern.some(mm => mm.match(node.fileName));\n        }\n\n        if (isExternal && this.converter.excludeExternals) {\n            return;\n        }\n\n        let isDeclaration = node.isDeclarationFile;\n        if (isDeclaration) {\n            const lib = this.converter.getDefaultLib();\n            const isLib = node.fileName.substr(-lib.length) === lib;\n            if (!this.converter.includeDeclarations || isLib) {\n                return;\n            }\n        }\n\n        this.isExternal = isExternal;\n        this.isDeclaration = isDeclaration;\n\n        this.trigger(Converter.EVENT_FILE_BEGIN, this.project, node);\n        callback();\n\n        this.isExternal = false;\n        this.isDeclaration = false;\n    }\n\n    /**\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope: Reflection | undefined, callback: () => void): void;\n\n    /**\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(\n        scope: Reflection | undefined,\n        parameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined,\n        callback: () => void): void;\n\n    /**\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\n     * @param preserve  Should the currently set type parameters of the context be preserved?\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(\n        scope: Reflection | undefined,\n        parameters: ts.NodeArray<ts.TypeParameterDeclaration> | undefined,\n        preserve: boolean,\n        callback: () => void): void;\n\n    /**\n     * Run the given callback with the scope of the context set to the given reflection.\n     *\n     * @param scope  The reflection that should be set as the scope of the context while the callback is invoked.\n     */\n    public withScope(scope: Reflection, ...args: any[]): void {\n        if (!scope || !args.length) {\n            return;\n        }\n        const callback = args.pop();\n        const parameters = args.shift();\n\n        const oldScope = this.scope;\n        const oldTypeArguments = this.typeArguments;\n        const oldTypeParameters = this.typeParameters;\n\n        this.scope = scope;\n        this.typeParameters = parameters ? this.extractTypeParameters(parameters, args.length > 0) : this.typeParameters;\n        this.typeArguments = undefined;\n\n        callback();\n\n        this.scope = oldScope;\n        this.typeParameters = oldTypeParameters;\n        this.typeArguments = oldTypeArguments;\n    }\n\n    /**\n     * Inherit the children of the given TypeScript node to the current scope.\n     *\n     * @param baseNode  The node whose children should be inherited.\n     * @param typeArguments  The type arguments that apply while inheriting the given node.\n     * @return The resulting reflection / the current scope.\n     */\n    inherit(baseNode: ts.Node, typeArguments?: ts.NodeArray<ts.TypeNode>): Reflection {\n        const wasInherit = this.isInherit;\n        const oldInherited = this.inherited;\n        const oldInheritParent = this.inheritParent;\n        const oldTypeArguments = this.typeArguments;\n\n        this.isInherit = true;\n        this.inheritParent = baseNode;\n        this.inherited = [];\n\n        const target = <ContainerReflection> this.scope;\n        if (!(target instanceof ContainerReflection)) {\n            throw new Error('Expected container reflection');\n        }\n\n        if (baseNode.symbol) {\n            const id = this.getSymbolID(baseNode.symbol)!;\n            if (this.inheritedChildren && this.inheritedChildren.includes(id)) {\n                return target;\n            } else {\n                this.inheritedChildren = this.inheritedChildren || [];\n                this.inheritedChildren.push(id);\n            }\n        }\n\n        if (target.children) {\n            this.inherited = target.children.map((c) => c.name);\n        } else {\n            this.inherited = [];\n        }\n\n        if (typeArguments) {\n            this.typeArguments = this.converter.convertTypes(this, typeArguments);\n        } else {\n            this.typeArguments = undefined;\n        }\n\n        this.converter.convertNode(this, baseNode);\n\n        this.isInherit = wasInherit;\n        this.inherited = oldInherited;\n        this.inheritParent = oldInheritParent;\n        this.typeArguments = oldTypeArguments;\n\n        if (!this.isInherit) {\n            delete this.inheritedChildren;\n        }\n\n        return target;\n    }\n\n    /**\n     * Convert the given list of type parameter declarations into a type mapping.\n     *\n     * @param parameters  The list of type parameter declarations that should be converted.\n     * @param preserve  Should the currently set type parameters of the context be preserved?\n     * @returns The resulting type mapping.\n     */\n    private extractTypeParameters(parameters: ts.NodeArray<ts.TypeParameterDeclaration>, preserve?: boolean): ts.MapLike<Type> {\n        const typeParameters: ts.MapLike<Type> = {};\n\n        if (preserve) {\n            Object.keys(this.typeParameters || {}).forEach(key => {\n                typeParameters[key] = this.typeParameters![key];\n            });\n        }\n\n        parameters.forEach((declaration: ts.TypeParameterDeclaration, index: number) => {\n            if (!declaration.symbol) {\n                return;\n            }\n            const name = declaration.symbol.name;\n            if (this.typeArguments && this.typeArguments[index]) {\n                typeParameters[name] = this.typeArguments[index];\n            } else {\n                const param = createTypeParameter(this, declaration);\n                if (param) {\n                    typeParameters[name] = param;\n                }\n            }\n        });\n\n        return typeParameters;\n    }\n}\n"]}