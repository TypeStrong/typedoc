{"version":3,"file":"components.js","sourceRoot":"","sources":["../../../src/lib/serialization/components.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,oCAA6C;AAC7C,kCAA6C;AAsB7C;IAAqD,uCAA6B;IAAlF;;IAqDA,CAAC;IARC,sBAAI,yCAAQ;aAAZ;YACE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QACtC,CAAC;;;OAAA;IAzCM,4BAAQ,GAAG,CAAC,CAAC;IA+CtB,0BAAC;CAAA,AArDD,CAAqD,yBAAiB,GAqDrE;AArDqB,kDAAmB;AAuDzC;IAAkF,iDAAsB;IAAxG;QAAA,qEAgBC;QANC,oBAAc,GAAG,6BAA6B,CAAC,cAAc,CAAC;QAC9D,0BAAoB,GAAG,mBAAU,CAAC;;IAKpC,CAAC;IAXkB,4CAAc,GAA/B,UAAgC,QAAa;QAC3C,MAAM,CAAC,QAAQ,YAAY,mBAAU,CAAC;IACxC,CAAC;IASH,oCAAC;AAAD,CAAC,AAhBD,CAAkF,mBAAmB,GAgBpG;AAhBqB,sEAA6B;AAkBnD;IAAsE,2CAAsB;IAA5F;QAAA,qEAgBC;QANC,oBAAc,GAAG,uBAAuB,CAAC,cAAc,CAAC;QACxD,0BAAoB,GAAG,aAAI,CAAC;;IAK9B,CAAC;IAXkB,sCAAc,GAA/B,UAAgC,QAAa;QAC3C,MAAM,CAAC,QAAQ,YAAY,aAAI,CAAC;IAClC,CAAC;IASH,8BAAC;AAAD,CAAC,AAhBD,CAAsE,mBAAmB,GAgBxF;AAhBqB,0DAAuB","sourcesContent":["import { Reflection, Type } from '../models';\nimport { AbstractComponent } from '../utils';\n\nimport { Serializer } from './serializer';\n\n/**\n * Represents Serializer plugin component.\n *\n * Like [[Converter]] plugins each [[Serializer]] plugin defines a predicate that instructs if an\n * object can be serialized by it, this is done dynamically at runtime via a `supports` method.\n *\n * Additionally, each [[Serializer]] plugin must defines a predicate that instructs the group\n * it belongs to.\n *\n * Grouping serializers is required due to performance, we don't need to check all the reflection\n * serializers when we are looking for type (or any other) serializers.\n *\n * [[Serializer]] will compare the function referenced in `serializeGroup` for each serializer\n * component instance, this is why, when extending [[SerializerComponent]], it is recommended to\n * reference `serializeGroup` to an existing function instead of creating a new function on for\n * every new plugin. This will ensure maximum performance.\n * > It is also possible to set a get accessor in the prototype to return the same function.\n */\nexport abstract class SerializerComponent<T> extends AbstractComponent<Serializer> {\n\n  /**\n   * The priority this serializer should be executed with.\n   * A higher priority means the [[Serializer]] will be applied earlier.\n   */\n  static PRIORITY = 0;\n\n  /**\n   * A high-level predicate filtering which group this serializer belongs to.\n   * This is a high-level filter before the [[SerializerComponent.supports]] predicate filter.\n   *\n   * When the filter returns true the group identifier is taken from\n   * [[SerializerComponentType.serializeGroupSymbol]].\n   *\n   * For example, use the [[Reflection]] class class to group all reflection based serializers:\n   * ```typescript\n   * class ReflectionSerializer {\n   *  serializeGroup = instance => instance instanceof Reflection ? Reflection : undefined;\n   *  serializeGroupSymbol = Reflection;\n   * }\n   * ```\n   *\n   * Use the [[Type]] class to group all type based serializers:\n   * ```typescript\n   * class TypeSerializer {\n   *  serializeGroup = instance => instance instanceof Type ? Type : undefined;\n   *  serializeGroupSymbol = Type;\n   * }\n   * ```\n   *\n   * > When a serializer component extends a parent serializer component the SERIALIZE_GROUP\n   * and SERIALIZE_GROUP_SYMBOL are also inherited so child serializers of the same group does not\n   * need to declare a predicate nor a group.\n   */\n  abstract serializeGroup: (instance: boolean) => boolean;\n  /**\n   * The symbol representing the group this serializer belongs to.\n   */\n  abstract serializeGroupSymbol: any;\n\n  /**\n   * The priority this serializer should be executed with.\n   * A higher priority means the [[Serializer]] will be applied earlier.\n   */\n  get priority(): number {\n    return this.constructor['PRIORITY'];\n  }\n\n  supports: (item: T) => boolean;\n\n  abstract toObject(item: T, obj?: any): any;\n\n}\n\nexport abstract class ReflectionSerializerComponent<T extends Reflection> extends SerializerComponent<T> {\n\n  /**\n   * Filter for instances of [[Reflection]]\n   */\n  protected static serializeGroup(instance: any): boolean {\n    return instance instanceof Reflection;\n  }\n\n  // use same fn for every instance\n  serializeGroup = ReflectionSerializerComponent.serializeGroup;\n  serializeGroupSymbol = Reflection;\n\n  supports: (reflection: T) => boolean;\n\n  abstract toObject(reflection: T, obj?: any): any;\n}\n\nexport abstract class TypeSerializerComponent<T extends Type> extends SerializerComponent<T> {\n\n  /**\n   * Filter for instances of [[Type]]\n   */\n  protected static serializeGroup(instance: any): boolean {\n    return instance instanceof Type;\n  }\n\n  // use same fn for every instance\n  serializeGroup = TypeSerializerComponent.serializeGroup;\n  serializeGroupSymbol = Type;\n\n  supports: (type: T) => boolean;\n\n  abstract toObject(type: T, obj?: any): any;\n}\n"]}