{"version":3,"file":"components.js","sourceRoot":"","sources":["../../../src/lib/serialization/components.ts"],"names":[],"mappings":";;AAAA,sCAA6C;AAC7C,oCAA6C;AAgB7C,MAAsB,mBAAuB,SAAQ,yBAA6B;IA6ChF,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IACtC,CAAC;;AAzCM,4BAAQ,GAAG,CAAC,CAAC;AANtB,kDAqDC;AAED,MAAsB,6BAAoD,SAAQ,mBAAsB;IAAxG;;QASE,yBAAoB,GAAG,mBAAU,CAAC;IACpC,CAAC;IALC,cAAc,CAAC,QAAiB;QAC9B,OAAO,QAAQ,YAAY,mBAAU,CAAC;IACxC,CAAC;CAGF;AAVD,sEAUC;AAED,MAAsB,uBAAwC,SAAQ,mBAAsB;IAA5F;;QASE,yBAAoB,GAAG,aAAI,CAAC;IAC9B,CAAC;IALC,cAAc,CAAC,QAAiB;QAC9B,OAAO,QAAQ,YAAY,aAAI,CAAC;IAClC,CAAC;CAGF;AAVD,0DAUC","sourcesContent":["import { Reflection, Type } from '../models';\nimport { AbstractComponent } from '../utils';\n\nimport { Serializer } from './serializer';\n\n/**\n * Represents Serializer plugin component.\n *\n * Like [[Converter]] plugins each [[Serializer]] plugin defines a predicate that instructs if an\n * object can be serialized by it, this is done dynamically at runtime via a `supports` method.\n *\n * Additionally, each [[Serializer]] plugin must defines a predicate that instructs the group\n * it belongs to.\n *\n * Grouping serializers is required due to performance, we don't need to check all the reflection\n * serializers when we are looking for type (or any other) serializers.\n */\nexport abstract class SerializerComponent<T> extends AbstractComponent<Serializer> {\n\n  /**\n   * The priority this serializer should be executed with.\n   * A higher priority means the [[Serializer]] will be applied earlier.\n   */\n  static PRIORITY = 0;\n\n  /**\n   * A high-level predicate filtering which group this serializer belongs to.\n   * This is a high-level filter before the [[SerializerComponent.supports]] predicate filter.\n   *\n   * When the filter returns true the group identifier is taken from\n   * [[SerializerComponentType.serializeGroupSymbol]].\n   *\n   * For example, use the [[Reflection]] class class to group all reflection based serializers:\n   * ```typescript\n   * class ReflectionSerializer {\n   *  serializeGroup(instance) { return instance instanceof Reflection }\n   *  serializeGroupSymbol = Reflection;\n   * }\n   * ```\n   *\n   * Use the [[Type]] class to group all type based serializers:\n   * ```typescript\n   * class TypeSerializer {\n   *  serializeGroup(instance) { return instance instanceof Type }\n   *  serializeGroupSymbol = Type;\n   * }\n   * ```\n   *\n   * > When a serializer component extends a parent serializer component the SERIALIZE_GROUP\n   * and SERIALIZE_GROUP_SYMBOL are also inherited so child serializers of the same group do not\n   * need to declare a predicate nor a group.\n   */\n  abstract serializeGroup(instance: unknown): boolean;\n  /**\n   * The symbol representing the group this serializer belongs to.\n   */\n  abstract serializeGroupSymbol: any;\n\n  /**\n   * The priority this serializer should be executed with.\n   * A higher priority means the [[Serializer]] will be applied earlier.\n   */\n  get priority(): number {\n    return this.constructor['PRIORITY'];\n  }\n\n  abstract supports(item: unknown): boolean;\n\n  abstract toObject(item: T, obj?: any): any;\n\n}\n\nexport abstract class ReflectionSerializerComponent<T extends Reflection> extends SerializerComponent<T> {\n\n  /**\n   * Filter for instances of [[Reflection]]\n   */\n  serializeGroup(instance: unknown): boolean {\n    return instance instanceof Reflection;\n  }\n\n  serializeGroupSymbol = Reflection;\n}\n\nexport abstract class TypeSerializerComponent<T extends Type> extends SerializerComponent<T> {\n\n  /**\n   * Filter for instances of [[Type]]\n   */\n  serializeGroup(instance: unknown): boolean {\n    return instance instanceof Type;\n  }\n\n  serializeGroupSymbol = Type;\n}\n"]}