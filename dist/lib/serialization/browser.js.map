{"version":3,"file":"browser.js","sourceRoot":"","sources":["../../../src/lib/serialization/browser.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Shared serialized symbols\n * The shared symbols can be used in node or in a browser web application.\n *\n * There are 2 types of symbols:\n *   - Object\n *   - Container\n *\n * ## Object\n * Object symbols (XXXObject) represents the final structure of a JSON object after it was\n * serialized by the native typedoc serializers. It is a type composition of Container symbols.\n *\n * ## Container\n * Container symbols (XXXContainer) are partial symbols used to compose an Object symbol.\n *\n * ## Object vs Container symbols\n * While Container symbols might look redundant they are not, when an external serialization plugin\n * is used it will, most likely, alter the structure of the output, the plugin can then use the\n * Container symbols to expose custom Object symbols with minimal effort.\n */\n\nexport interface ReflectionContainer {\n  id: number;\n  name: string;\n  kind: number;\n  kindString: string;\n  flags: ReflectionFlagsObject;\n  originalName?: string;\n}\n\nexport interface DefaultValueContainer {\n  defaultValue: string;\n}\n\nexport interface TypeContainer  {\n  type: TypeObject;\n}\n\nexport interface TypeParameterContainer {\n  typeParameters: TypeContainer[];\n}\n\nexport interface DecoratesContainer {\n  decorates: TypeObject[];\n}\n\nexport interface DecoratorsContainer<T> {\n  decorators: T[];\n}\n\nexport interface SourceReferenceContainer<T> {\n  sources: T[];\n}\n\nexport interface GroupsContainer<T> {\n  groups: T[];\n}\n\nexport interface CategoriesContainer<T> {\n  categories: T[];\n}\n\nexport interface ContainerReflectionContainer<TChildren> {\n  children: TChildren[];\n}\n\nexport interface CommentContainer<TComment> {\n  comment: TComment;\n}\n\nexport interface SignatureReflectionContainer<TParameters> {\n  /**\n   * A type that points to the reflection that has been overwritten by this reflection.\n   *\n   * Applies to interface and class members.\n   */\n  overwrites?: TypeObject;\n\n  /**\n   * A type that points to the reflection this reflection has been inherited from.\n   *\n   * Applies to interface and class members.\n   */\n  inheritedFrom?: TypeObject;\n\n  /**\n   * A type that points to the reflection this reflection is the implementation of.\n   *\n   * Applies to class members.\n   */\n  implementationOf?: TypeObject;\n\n  parameters?: TParameters[];\n}\n\nexport interface DeclarationReflectionContainer<T> {\n  /**\n   * A list of call signatures attached to this declaration.\n   *\n   * TypeDoc creates one declaration per function that may contain ore or more\n   * signature reflections.\n   */\n  signatures?: T[];\n\n  /**\n   * The index signature of this declaration.\n   */\n  indexSignature?: T[];\n\n  /**\n   * The get signature of this declaration.\n   */\n  getSignature?: T[];\n\n  /**\n   * The set signature of this declaration.\n   */\n  setSignature?: T[];\n\n  /**\n   * A list of all types this reflection extends (e.g. the parent classes).\n   */\n  extendedTypes?: TypeObject[];\n\n  /**\n   * A list of all types that extend this reflection (e.g. the subclasses).\n   */\n  extendedBy?: TypeObject[];\n\n  /**\n   * A list of all types this reflection implements.\n   */\n  implementedTypes?: TypeObject[];\n\n  /**\n   * A list of all types that implement this reflection.\n   */\n  implementedBy?: TypeObject[];\n\n}\n\nexport interface ReflectionObject extends ReflectionContainer,\n                                          Partial<CommentContainer<CommentObject>>,\n                                          Partial<DecoratesContainer>,\n                                          Partial<DecoratorsContainer<DecoratorObject>> { }\n\nexport interface ParameterReflectionObject extends  ReflectionObject,\n                                                    TypeContainer,\n                                                    DefaultValueContainer {}\n\nexport interface ContainerReflectionObject extends  ReflectionObject,\n                                                    Partial<SourceReferenceContainer<SourceReferenceObject>>,\n                                                    Partial<GroupsContainer<ReflectionGroupObject>>,\n                                                    Partial<CategoriesContainer<ReflectionCategoryObject>>,\n                                                    ContainerReflectionContainer<ReflectionObject> {}\n\nexport interface DeclarationReflectionObject extends  ContainerReflectionObject,\n                                                      DefaultValueContainer,\n                                                      Partial<TypeContainer>,\n                                                      Partial<TypeParameterContainer>,\n                                                      Partial<SignatureReflectionContainer<ParameterReflectionObject>>,\n                                                      DeclarationReflectionContainer<SignatureReflectionObject> {}\n\nexport interface SignatureReflectionObject extends  ReflectionObject,\n                                                    Partial<SignatureReflectionContainer<ParameterReflectionObject>>,\n                                                    Partial<TypeContainer>,\n                                                    Partial<TypeParameterContainer> { }\n\nexport interface CommentObject {\n  shortText?: string;\n  text?: string;\n  returns?: string;\n  tags?: CommentTagObject[];\n}\n\nexport interface CommentTagObject {\n  tag: string;\n  text: string;\n  param?: string;\n}\n\nexport interface DecoratorObject {\n  /**\n   * The name of the decorator being applied.\n   */\n  name: string;\n\n  /**\n   * The type declaring the decorator.\n   * Usually a ReferenceType instance pointing to the decorator function.\n   */\n  type?: TypeObject;\n\n  /**\n   * A named map of arguments the decorator is applied with.\n   */\n  arguments?: any;\n}\n\nexport interface ProjectReflectionObject extends ContainerReflectionObject { }\n\nexport interface SourceReferenceObject {\n  fileName: string;\n  line: number;\n  character: number;\n}\n\nexport interface TypeObject {\n\n  /**\n   * The type name identifier.\n   */\n  type: 'void' | 'array' | 'intersection' | 'intrinsic' | 'reference' | 'reflection' | 'stringLiteral' | 'tuple' | 'typeParameter' | 'union' | 'unknown' | string;\n\n  // array\n  /**\n   * For Array type only, The type (T) of the array's elements.\n   */\n  elementType?: TypeObject;\n\n  // intersection\n  /**\n   * For intersection type only, the types the union consists of.\n   * For union type only, the types the union consists of.\n   */\n  types?: TypeObject[];\n\n  // intrinsic, reference, typeParameter, unknown\n  /**\n   * For intrinsic type only, The name of the intrinsic type like `string` or `boolean`.\n   *\n   * For reference type only,  The name of the referenced type.\n   * If the symbol cannot be found cause it's not part of the documentation this\n   * can be used to represent the type.\n   *\n   * For typeParameter type only, the name of the type.\n   *\n   * For unknown type only, the name of the type.\n   */\n  name?: 'Object' | 'string' | 'number' | 'boolean' | 'this' | string;\n\n  // reference\n  /**\n   * The reflection id for this type\n   */\n  id?: number;\n\n  /**\n   * For reference type only, The type arguments of this reference.\n   */\n  typeArguments?: TypeObject[];\n\n  // reflection\n  /**\n   * For reflection type only, The reflection of the type.\n   */\n  declaration?: ReflectionObject;\n\n  // stringLiteral\n  /**\n   * For stringLiteral type only, The string literal value.\n   */\n  value?: string;\n\n  // tuple\n  /**\n   * For tuple type only, The ordered type elements of the tuple type.\n   */\n  elements?: TypeObject[];\n\n  // typeParameter\n  /**\n   * For typeParameter type only, The constraint type for the generic type.\n   */\n  constraint?: TypeObject;\n}\n\nexport interface ReflectionGroupObject {\n  /**\n   * The title, a string representation of the typescript kind, of this group.\n   */\n  title: string;\n\n  /**\n   * The original typescript kind of the children of this group.\n   */\n  kind: number;\n\n  /**\n   * A list of reflection id's for this group.\n   */\n  children?: number[];\n\n  /**\n   * A list of categories for this group.\n   */\n  categories?: ReflectionCategoryObject[];\n}\n\nexport interface ReflectionCategoryObject {\n  /**\n   * The title, a string representation of the typescript kind, of this category.\n   */\n  title: string;\n\n  /**\n   * A list of reflection id's for this category.\n   */\n  children?: number[];\n}\n\nexport interface ReflectionFlagsObject {\n  /**\n   * Is this a private member?\n   */\n  isPrivate?: boolean;\n\n  /**\n   * Is this a protected member?\n   */\n  isProtected?: boolean;\n\n  /**\n   * Is this a public member?\n   */\n  isPublic?: boolean;\n\n  /**\n   * Is this a static member?\n   */\n  isStatic?: boolean;\n\n  /**\n   * Is this member exported?\n   */\n  isExported?: boolean;\n\n  /**\n   * Is this a declaration from an external document?\n   */\n  isExternal?: boolean;\n\n  /**\n   * Whether this reflection is an optional component or not.\n   *\n   * Applies to function parameters and object members.\n   */\n  isOptional?: boolean;\n\n  /**\n   * Whether it's a rest parameter, like `foo(...params);`.\n   */\n  isRest?: boolean;\n\n  /**\n   *\n   */\n  hasExportAssignment?: boolean;\n\n  isConstructorProperty?: boolean;\n}\n"]}