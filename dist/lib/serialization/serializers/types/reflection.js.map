{"version":3,"file":"reflection.js","sourceRoot":"","sources":["../../../../../src/lib/serialization/serializers/types/reflection.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,sDAAqD;AACrD,0CAAwE;AAExE,+CAA2D;AAG3D;IAA8C,4CAAuC;IAArF;;IAqCA,CAAC;IAjCC,6CAAU,GAAV;QACE,iBAAM,UAAU,WAAE,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,UAAC,CAAiB,IAAK,OAAA,CAAC,YAAY,uBAAc,EAA3B,CAA2B,CAAC;IACrE,CAAC;IAED,2CAAQ,GAAR,UAAS,SAAyB,EAAE,GAAS;QAC3C,GAAG,GAAG,GAAG,IAAI,EAAE,CAAC;QAEhB,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;YAO1B,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;gBAG/C,GAAG,CAAC,WAAW,GAAG,EAAE,EAAE,EAAE,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;YACrD,CAAC;YAAC,IAAI,CAAC,CAAC;gBAEN,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;gBAGzC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;YAC/D,CAAC;YAGD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;QAC/B,CAAC;QAED,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IApCU,wBAAwB;QADpC,qBAAS,CAAC,EAAC,IAAI,EAAE,4BAA4B,EAAC,CAAC;OACnC,wBAAwB,CAqCpC;IAAD,+BAAC;CAAA,AArCD,CAA8C,oCAAuB,GAqCpE;AArCY,4DAAwB","sourcesContent":["import { Component } from '../../../utils/component';\nimport { DeclarationReflection, ReflectionType } from '../../../models';\n\nimport { TypeSerializerComponent } from '../../components';\n\n@Component({name: 'serializer:reflection-type'})\nexport class ReflectionTypeSerializer extends TypeSerializerComponent<ReflectionType> {\n\n  private declaration: DeclarationReflection;\n\n  initialize(): void {\n    super.initialize();\n    this.supports = (t: ReflectionType) => t instanceof ReflectionType;\n  }\n\n  toObject(reference: ReflectionType, obj?: any): any {\n    obj = obj || {};\n\n    if (reference.declaration) {\n\n      // Because `DeclarationReflection` has reference to multiple types objectifying a declaration\n      // on a type might fall into a loop trap (cyclic dependency).\n      // The TypeDoc code does not apply logic that can create this scenario but a 3rd party plugin\n      // might do that unintentionally so a protection is in place.\n\n      if (this.declaration === reference.declaration) {\n        // if we're here it means that the reference type is rendered for the 2nd time\n        // by the declaration it is referencing, we will render a pointer-only declaration.\n        obj.declaration = { id: reference.declaration.id };\n      } else {\n        // mark this declaration to trap a loop\n        this.declaration = reference.declaration;\n\n        // objectify the declaration\n        obj.declaration = this.owner.toObject(reference.declaration);\n      }\n\n      // no more declaration rendering, remove marker.\n      this.declaration = undefined;\n    }\n\n    return obj;\n  }\n}\n"]}