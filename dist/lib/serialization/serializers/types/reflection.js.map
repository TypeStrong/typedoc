{"version":3,"file":"reflection.js","sourceRoot":"","sources":["../../../../../src/lib/serialization/serializers/types/reflection.ts"],"names":[],"mappings":";;;;;;;;AAAA,wDAAqD;AACrD,4CAAwE;AAExE,iDAA2D;AAG3D,IAAa,wBAAwB,GAArC,MAAa,wBAAyB,SAAQ,oCAAuC;IAInF,QAAQ,CAAC,CAAU;QACjB,OAAO,CAAC,YAAY,uBAAc,CAAC;IACrC,CAAC;IAED,QAAQ,CAAC,SAAyB,EAAE,GAAS;QAC3C,GAAG,GAAG,GAAG,IAAI,EAAE,CAAC;QAEhB,IAAI,SAAS,CAAC,WAAW,EAAE;YAOzB,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,WAAW,EAAE;gBAG9C,GAAG,CAAC,WAAW,GAAG,EAAE,EAAE,EAAE,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;aACpD;iBAAM;gBAEL,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;gBAGzC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;aAC9D;YAGD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;SAC9B;QAED,OAAO,GAAG,CAAC;IACb,CAAC;CACF,CAAA;AApCY,wBAAwB;IADpC,qBAAS,CAAC,EAAC,IAAI,EAAE,4BAA4B,EAAC,CAAC;GACnC,wBAAwB,CAoCpC;AApCY,4DAAwB","sourcesContent":["import { Component } from '../../../utils/component';\nimport { DeclarationReflection, ReflectionType } from '../../../models';\n\nimport { TypeSerializerComponent } from '../../components';\n\n@Component({name: 'serializer:reflection-type'})\nexport class ReflectionTypeSerializer extends TypeSerializerComponent<ReflectionType> {\n\n  private declaration?: DeclarationReflection;\n\n  supports(t: unknown) {\n    return t instanceof ReflectionType;\n  }\n\n  toObject(reference: ReflectionType, obj?: any): any {\n    obj = obj || {};\n\n    if (reference.declaration) {\n\n      // Because `DeclarationReflection` has reference to multiple types objectifying a declaration\n      // on a type might fall into a loop trap (cyclic dependency).\n      // The TypeDoc code does not apply logic that can create this scenario but a 3rd party plugin\n      // might do that unintentionally so a protection is in place.\n\n      if (this.declaration === reference.declaration) {\n        // if we're here it means that the reference type is rendered for the 2nd time\n        // by the declaration it is referencing, we will render a pointer-only declaration.\n        obj.declaration = { id: reference.declaration.id };\n      } else {\n        // mark this declaration to trap a loop\n        this.declaration = reference.declaration;\n\n        // objectify the declaration\n        obj.declaration = this.owner.toObject(reference.declaration);\n      }\n\n      // no more declaration rendering, remove marker.\n      this.declaration = undefined;\n    }\n\n    return obj;\n  }\n}\n"]}