{"version":3,"file":"arguments.js","sourceRoot":"","sources":["../../../../../src/lib/utils/options/readers/arguments.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport * as _ts from '../../../ts-internal';\n\nimport { Component } from '../../component';\nimport { DiscoverEvent, OptionsComponent } from '../options';\nimport { ParameterType } from '../declaration';\n\n@Component({name: 'options:arguments'})\nexport class ArgumentsReader extends OptionsComponent {\n    initialize() {\n        this.listenTo(this.owner, DiscoverEvent.DISCOVER, this.onDiscover, -200);\n    }\n\n    onDiscover(event: DiscoverEvent) {\n        if (this.application.isCLI) {\n            this.parseArguments(event);\n        }\n    }\n\n    /**\n     * Read and store the given list of arguments.\n     *\n     * @param args  The list of arguments that should be parsed. When omitted the\n     *   current command line arguments will be used.\n     * @param ignoreUnknownArgs  Should unknown arguments be ignored? If so the parser\n     *   will simply skip all unknown arguments.\n     * @returns TRUE on success, otherwise FALSE.\n     */\n    private parseArguments(event: DiscoverEvent, args?: string[]) {\n        let index = 0;\n        const owner = this.owner;\n        args = args || process.argv.slice(2);\n\n        function readArgument(arg: string) {\n            const declaration = owner.getDeclaration(arg);\n            if (!declaration) {\n                event.addError('Unknown option: %s', arg);\n            } else if (declaration.type !== ParameterType.Boolean) {\n                if (!args[index]) {\n                    event.addError('Option \"%s\" expects an argument', declaration.name);\n                } else {\n                    event.data[declaration.name] = args[index++];\n                }\n            } else {\n                event.data[declaration.name] = true;\n            }\n        }\n\n        const files = [];\n        while (index < args.length) {\n            const arg = args[index++];\n\n            if (arg.charCodeAt(0) === _ts.CharacterCodes.at) {\n                this.parseResponseFile(event, arg.slice(1));\n            } else if (arg.charCodeAt(0) === _ts.CharacterCodes.minus) {\n                readArgument(arg.slice(arg.charCodeAt(1) === _ts.CharacterCodes.minus ? 2 : 1).toLowerCase());\n            } else {\n                files.push(arg);\n            }\n        }\n        if (files) {\n            event.inputFiles = files;\n        }\n    }\n\n    /**\n     * Read the arguments stored in the given file.\n     *\n     * @param filename  The path and filename that should be parsed.\n     * @param ignoreUnknownArgs  Should unknown arguments be ignored?\n     * @returns TRUE on success, otherwise FALSE.\n     */\n    private parseResponseFile(event: DiscoverEvent, filename: string) {\n        const text = ts.sys.readFile(filename);\n        if (!text) {\n            event.addError('File not found: \"%s\"', filename);\n            return;\n        }\n\n        const args: string[] = [];\n        let pos = 0;\n        while (true) {\n            while (pos < text.length && text.charCodeAt(pos) <= _ts.CharacterCodes.space) {\n                pos++;\n            }\n            if (pos >= text.length) {\n                break;\n            }\n\n            const start = pos;\n            if (text.charCodeAt(start) === _ts.CharacterCodes.doubleQuote) {\n                pos++;\n                while (pos < text.length && text.charCodeAt(pos) !== _ts.CharacterCodes.doubleQuote) {\n                    pos++;\n                }\n                if (pos < text.length) {\n                    args.push(text.substring(start + 1, pos));\n                    pos++;\n                } else {\n                    event.addError('Unterminated quoted string in response file \"%s\"', filename);\n                    return;\n                }\n            } else {\n                while (text.charCodeAt(pos) > _ts.CharacterCodes.space) {\n                    pos++;\n                }\n                args.push(text.substring(start, pos));\n            }\n        }\n\n        this.parseArguments(event, args);\n    }\n}\n"]}