{"version":3,"file":"arguments.js","sourceRoot":"","sources":["../../../../../src/lib/utils/options/readers/arguments.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport * as _ts from '../../../ts-internal';\n\nimport { Component } from '../../component';\nimport { DiscoverEvent, OptionsComponent } from '../options';\nimport { ParameterType } from '../declaration';\n\n/**\n * ASCII Values\n * https://www.ascii-code.com/\n */\nenum CharacterCodes {\n    space = 0x20,\n    doubleQuote = 0x22,\n    at = 0x40,\n    minus = 0x2d\n}\n\n/**\n * Obtains option values from command-line arguments\n */\n@Component({name: 'options:arguments'})\nexport class ArgumentsReader extends OptionsComponent {\n    initialize() {\n        this.listenTo(this.owner, DiscoverEvent.DISCOVER, this.onDiscover, -200);\n    }\n\n    onDiscover(event: DiscoverEvent) {\n        if (this.application.isCLI) {\n            this.parseArguments(event);\n        }\n    }\n\n    /**\n     * Read and store the given list of arguments.\n     *\n     * @param passedArgs  The list of arguments that should be parsed. When omitted the\n     *   current command line arguments will be used.\n     * @param ignoreUnknownArgs  Should unknown arguments be ignored? If so the parser\n     *   will simply skip all unknown arguments.\n     * @returns TRUE on success, otherwise FALSE.\n     */\n    private parseArguments(event: DiscoverEvent, passedArgs?: string[]) {\n        let index = 0;\n        const owner = this.owner;\n        const args = passedArgs || process.argv.slice(2);\n\n        function readArgument(arg: string) {\n            const declaration = owner.getDeclaration(arg);\n            if (!declaration) {\n                event.addError('Unknown option: %s', arg);\n            } else if (declaration.type !== ParameterType.Boolean) {\n                if (!args[index]) {\n                    event.addError('Option \"%s\" expects an argument', declaration.name);\n                } else {\n                    event.data[declaration.name] = args[index++];\n                }\n            } else {\n                event.data[declaration.name] = true;\n            }\n        }\n\n        const files: string[] = [];\n        while (index < args.length) {\n            const arg = args[index++];\n\n            if (arg.charCodeAt(0) === CharacterCodes.at) {\n                this.parseResponseFile(event, arg.slice(1));\n            } else if (arg.charCodeAt(0) === CharacterCodes.minus) {\n                readArgument(arg.slice(arg.charCodeAt(1) === CharacterCodes.minus ? 2 : 1).toLowerCase());\n            } else {\n                files.push(arg);\n            }\n        }\n        if (files && files.length > 0) {\n            event.inputFiles = files;\n        }\n    }\n\n    /**\n     * Read the arguments stored in the given file.\n     *\n     * @param filename  The path and filename that should be parsed.\n     * @param ignoreUnknownArgs  Should unknown arguments be ignored?\n     * @returns TRUE on success, otherwise FALSE.\n     */\n    private parseResponseFile(event: DiscoverEvent, filename: string) {\n        const text = ts.sys.readFile(filename);\n        if (!text) {\n            event.addError('File not found: \"%s\"', filename);\n            return;\n        }\n\n        const args: string[] = [];\n        let pos = 0;\n        while (true) {\n            while (pos < text.length && text.charCodeAt(pos) <= CharacterCodes.space) {\n                pos++;\n            }\n            if (pos >= text.length) {\n                break;\n            }\n\n            const start = pos;\n            if (text.charCodeAt(start) === CharacterCodes.doubleQuote) {\n                pos++;\n                while (pos < text.length && text.charCodeAt(pos) !== CharacterCodes.doubleQuote) {\n                    pos++;\n                }\n                if (pos < text.length) {\n                    args.push(text.substring(start + 1, pos));\n                    pos++;\n                } else {\n                    event.addError('Unterminated quoted string in response file \"%s\"', filename);\n                    return;\n                }\n            } else {\n                while (text.charCodeAt(pos) > CharacterCodes.space) {\n                    pos++;\n                }\n                args.push(text.substring(start, pos));\n            }\n        }\n\n        this.parseArguments(event, args);\n    }\n}\n"]}