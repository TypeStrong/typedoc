{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../../src/lib/utils/options/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\n\nexport enum ParameterHint {\n    File,\n    Directory\n}\n\nexport enum ParameterType {\n    String,\n    Number,\n    Boolean,\n    Map,\n    Mixed,\n    Array\n}\n\nexport enum ParameterScope {\n    TypeDoc,\n    TypeScript\n}\n\n/**\n * Option-bag passed to Option decorator.\n *\n * TODO: This should be a union type of multiple possible option types.\n */\nexport interface DeclarationOption {\n    name: string;\n    component?: string;\n    short?: string;\n    help: string;\n    type?: ParameterType;\n    hint?: ParameterHint;\n    scope?: ParameterScope;\n    map?: 'object' | Map<string | number, any> | { [ key: string]: any };\n    mapError?: string;\n    defaultValue?: any;\n    convert?: (param: OptionDeclaration, value?: any) => any;\n}\n\n/**\n * Runtime structure describing a configuration option.\n * Used by option parsing and validation.\n */\nexport class OptionDeclaration {\n    name!: string;\n\n    component?: string;\n\n    short?: string;\n\n    help!: string;\n\n    type: ParameterType = ParameterType.String;\n\n    hint?: ParameterHint;\n\n    scope: ParameterScope = ParameterScope.TypeDoc;\n\n    protected map?: { [k: string]: any } | 'object';\n\n    mapError?: string;\n\n    defaultValue: any;\n\n    constructor(data: DeclarationOption) {\n        for (let key in data) {\n            this[key] = data[key];\n        }\n    }\n\n    getNames(): string[] {\n        const result = [this.name.toLowerCase()];\n\n        if (this.short) {\n            result.push(this.short.toLowerCase());\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param value the value the user passed in\n     * @param errorCallback\n     */\n    convert(value: unknown, errorCallback?: (format: string, ...args: string[]) => void): any {\n        switch (this.type) {\n            case ParameterType.Number:\n                value = parseInt(value + '', 10);\n                break;\n            case ParameterType.Boolean:\n                value = !!value;\n                break;\n            case ParameterType.String:\n                value = value ? value + '' : '';\n                break;\n            case ParameterType.Array:\n                if (!value) {\n                    value = [];\n                // TSLint *should* be correct here, but tslint doesn't know about user config files.\n                // tslint:disable-next-line:strict-type-predicates\n                } else if (typeof value === 'string') {\n                    value = value.split(',');\n                }\n                break;\n            case ParameterType.Map:\n                const map = this.map || {};\n                if (map !== 'object') {\n                    const key = value ? (value + '').toLowerCase() : '';\n                    const values = _.values(map);\n\n                    if (map instanceof Map) {\n                        value = map.has(key) ? map.get(key) : value;\n                    } else if (key in map) {\n                        value = map[key];\n                    } else if (!values.includes(value) && errorCallback) {\n                        if (this.mapError) {\n                            errorCallback(this.mapError);\n                        } else {\n                            errorCallback('Invalid value for option \"%s\".', this.name);\n                        }\n                    }\n                }\n                break;\n        }\n\n        return value;\n    }\n}\n"]}