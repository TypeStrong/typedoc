{"version":3,"file":"abstract.js","sourceRoot":"","sources":["../../../../src/lib/models/types/abstract.ts"],"names":[],"mappings":";;AAKA,MAAsB,IAAI;IAA1B;QAKa,SAAI,GAAW,MAAM,CAAC;IA+EnC,CAAC;IAhEG,MAAM,CAAC,IAAU;QACb,OAAO,KAAK,CAAC;IACjB,CAAC;IAMD,QAAQ;QACJ,IAAI,MAAM,GAAQ,EAAE,CAAC;QACrB,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAExB,OAAO,MAAM,CAAC;IAClB,CAAC;IAKD,QAAQ;QACJ,OAAO,MAAM,CAAC;IAClB,CAAC;IAQD,MAAM,CAAC,iBAAiB,CAAC,CAAS,EAAE,CAAS;QACzC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;YACvB,OAAO,KAAK,CAAC;SAChB;QACD,SAAS,EAAE,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE,EAAE;YAC5D,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;YACjB,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE,EAAE;gBAC/B,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;oBAClB,SAAS,SAAS,CAAC;iBACtB;aACJ;YAED,OAAO,KAAK,CAAC;SAChB;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAQD,MAAM,CAAC,eAAe,CAAC,CAAS,EAAE,CAAS;QACvC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;YACvB,OAAO,KAAK,CAAC;SAChB;QACD,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK,EAAE,EAAE;YAC1D,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC5B,OAAO,KAAK,CAAC;aAChB;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;CACJ;AApFD,oBAoFC","sourcesContent":["/**\n * Base class of all type definitions.\n *\n * Instances of this class are also used to represent the type `void`.\n */\nexport abstract class Type {\n\n    /**\n     * The type name identifier.\n     */\n    readonly type: string = 'void';\n\n    /**\n     * Clone this type.\n     *\n     * @return A clone of this type.\n     */\n    abstract clone(): Type;\n\n    /**\n     * Test whether this type equals the given type.\n     *\n     * @param type  The type that should be checked for equality.\n     * @returns TRUE if the given type equals this type, FALSE otherwise.\n     */\n    equals(type: Type): boolean {\n        return false;\n    }\n\n    /**\n     * Return a raw object representation of this type.\n     * @deprecated Use serializers instead\n     */\n    toObject(): any {\n        let result: any = {};\n        result.type = this.type;\n\n        return result;\n    }\n\n    /**\n     * Return a string representation of this type.\n     */\n    toString(): string {\n        return 'void';\n    }\n\n    /**\n     * Test whether the two given list of types contain equal types.\n     *\n     * @param a\n     * @param b\n     */\n    static isTypeListSimilar(a: Type[], b: Type[]): boolean {\n        if (a.length !== b.length) {\n            return false;\n        }\n        outerLoop: for (let an = 0, count = a.length; an < count; an++) {\n            const at = a[an];\n            for (let bn = 0; bn < count; bn++) {\n                if (b[bn].equals(at)) {\n                    continue outerLoop;\n                }\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Test whether the two given list of types are equal.\n     *\n     * @param a\n     * @param b\n     */\n    static isTypeListEqual(a: Type[], b: Type[]): boolean {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let index = 0, count = a.length; index < count; index++) {\n            if (!a[index].equals(b[index])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"]}