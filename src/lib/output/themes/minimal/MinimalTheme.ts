import * as FS from "fs";
import * as Path from "path";

import { DefaultTheme } from "../default/DefaultTheme";
import { Renderer } from "../../renderer";
import { UrlMapping } from "../../models/UrlMapping";
import {
    Reflection,
    ProjectReflection,
    ContainerReflection,
} from "../../../models/reflections/index";
import { PageEvent } from "../../events";
import { NavigationItem } from "../../models/NavigationItem";
import { indexTemplate } from "./templates";
import { defaultLayout } from "./layouts/default";
import { DefaultThemePartials } from "../default/DefaultThemePartials";
import { DefaultThemeRenderContext } from "../default/DefaultThemeRenderContext";

export class MinimalTheme extends DefaultTheme {
    /**
     * Create a new DefaultTheme instance.
     *
     * @param renderer  The renderer this theme is attached to.
     * @param basePath  The base path of this theme.
     */
    constructor(renderer: Renderer, basePath: string) {
        super(renderer, basePath);

        renderer.removeComponent("assets");
        renderer.removeComponent("javascriptIndex");
        renderer.removeComponent("navigation");
        renderer.removeComponent("toc");

        this.listenTo(renderer, PageEvent.BEGIN, this.onRendererBeginPage);
    }

    override getRenderContext(_pageEvent: PageEvent<any>) {
        if (!this._renderContext) {
            this._renderContext = new MinimalThemeRenderContext(
                this._markedPlugin
            );
        }
        return this._renderContext;
    }

    /**
     * Test whether the given path contains a documentation generated by this theme.
     *
     * @param path  The path of the directory that should be tested.
     * @returns     TRUE if the given path seems to be a previous output directory,
     *              otherwise FALSE.
     */
    override isOutputDirectory(path: string): boolean {
        if (!FS.existsSync(Path.join(path, "index.html"))) {
            return false;
        }
        return true;
    }

    /**
     * Map the models of the given project to the desired output files.
     *
     * @param project  The project whose urls should be generated.
     * @returns        A list of [[UrlMapping]] instances defining which models
     *                 should be rendered to which files.
     */
    override getUrls(project: ProjectReflection): UrlMapping[] {
        const urls: UrlMapping[] = [];
        urls.push(new UrlMapping("index.html", project, this.indexTemplate));

        project.url = "index.html";
        project.anchor = undefined;
        project.hasOwnDocument = true;

        (project.children || []).forEach((child) => {
            DefaultTheme.applyAnchorUrl(child, project);
        });

        return urls;
    }

    /**
     * Triggered before a document will be rendered.
     *
     * @param page  An event object describing the current render operation.
     */
    private onRendererBeginPage(page: PageEvent<Reflection>) {
        const model = page.model;
        if (!(model instanceof Reflection)) {
            return;
        }

        page.toc = new NavigationItem();
        MinimalTheme.buildToc(page.model, page.toc);
    }

    /**
     * Create a toc navigation item structure.
     *
     * @param model   The models whose children should be written to the toc.
     * @param parent  The parent [[Models.NavigationItem]] the toc should be appended to.
     */
    static buildToc(model: Reflection, parent: NavigationItem) {
        const children = (model as ContainerReflection).children || [];
        children.forEach((child) => {
            const item = NavigationItem.create(child, parent, true);
            MinimalTheme.buildToc(child, item);
        });
    }
}

export class MinimalThemeRenderContext extends DefaultThemeRenderContext {}

export class MinimalThemePartials extends DefaultThemePartials {
    protected override bindings!: MinimalThemeRenderContext;
    constructor(bindings: MinimalThemeRenderContext) {
        super(bindings);
    }
    override indexTemplate = indexTemplate(this.bindings);
    override defaultLayout = defaultLayout(this.bindings);
}
