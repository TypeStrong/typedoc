{"version":3,"file":"application.js","sourceRoot":"","sources":["../src/lib/application.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The TypeDoc main module and namespace.\n *\n * The [[Application]] class holds the core logic of the cli application. All code related\n * to resolving reflections is stored in [[TypeDoc.Factories]], the actual data models can be found\n * in [[TypeDoc.Models]] and the final rendering is defined in [[TypeDoc.Output]].\n */\n\nimport * as Path from \"path\";\nimport * as FS from \"fs\";\nimport * as Util from \"util\";\nimport * as typescript from \"typescript\";\nimport {Minimatch, IMinimatch} from \"minimatch\";\n\nimport {Converter} from \"./converter/index\";\nimport {Renderer} from \"./output/renderer\";\nimport {ProjectReflection} from \"./models/index\";\nimport {Logger, ConsoleLogger, CallbackLogger, PluginHost, writeFile} from \"./utils/index\";\n\nimport {AbstractComponent, ChildableComponent, Component, Option} from \"./utils/component\";\nimport {Options, OptionsReadMode, IOptionsReadResult} from \"./utils/options/index\"\nimport {ParameterType} from \"./utils/options/declaration\";\n\n\n/**\n * The default TypeDoc main application class.\n *\n * This class holds the two main components of TypeDoc, the [[Dispatcher]] and\n * the [[Renderer]]. When running TypeDoc, first the [[Dispatcher]] is invoked which\n * generates a [[ProjectReflection]] from the passed in source files. The\n * [[ProjectReflection]] is a hierarchical model representation of the TypeScript\n * project. Afterwards the model is passed to the [[Renderer]] which uses an instance\n * of [[BaseTheme]] to generate the final documentation.\n *\n * Both the [[Dispatcher]] and the [[Renderer]] are subclasses of the [[EventDispatcher]]\n * and emit a series of events while processing the project. Subscribe to these Events\n * to control the application flow or alter the output.\n */\n@Component({name:\"application\", internal:true})\nexport class Application extends ChildableComponent<Application, AbstractComponent<Application>>\n{\n    options:Options;\n\n    /**\n     * The converter used to create the declaration reflections.\n     */\n    converter:Converter;\n\n    /**\n     * The renderer used to generate the documentation output.\n     */\n    renderer:Renderer;\n\n    /**\n     * The logger that should be used to output messages.\n     */\n    logger:Logger;\n\n    plugins:PluginHost;\n\n    @Option({\n        name: 'logger',\n        help: 'Specify the logger that should be used, \\'none\\' or \\'console\\'',\n        defaultValue: 'console',\n        type: ParameterType.Mixed,\n    })\n    loggerType:string|Function;\n\n    @Option({\n        name: 'ignoreCompilerErrors',\n        help: 'Should TypeDoc generate documentation pages even after the compiler has returned errors?',\n        type: ParameterType.Boolean\n    })\n    ignoreCompilerErrors:boolean;\n\n    @Option({\n        name: 'exclude',\n        help: 'Define a pattern for excluded files when specifying paths.',\n        type: ParameterType.String\n    })\n    exclude:string;\n\n    /**\n     * The version number of TypeDoc.\n     */\n    static VERSION:string = '{{ VERSION }}';\n\n\n\n    /**\n     * Create a new TypeDoc application instance.\n     *\n     * @param options An object containing the options that should be used.\n     */\n    constructor(options?:Object) {\n        super(null);\n\n        this.logger    = new ConsoleLogger();\n        this.converter = this.addComponent('converter', Converter);\n        this.renderer  = this.addComponent('renderer', Renderer);\n        this.plugins   = this.addComponent('plugins', PluginHost);\n        this.options   = this.addComponent('options', Options);\n\n        this.bootstrap(options);\n    }\n\n\n    /**\n     * Initialize TypeDoc with the given options object.\n     *\n     * @param options  The desired options to set.\n     */\n    protected bootstrap(options?:Object):IOptionsReadResult {\n        this.options.read(options, OptionsReadMode.Prefetch);\n\n        var logger = this.loggerType;\n        if (typeof logger == 'function') {\n            this.logger = new CallbackLogger(<any>logger);\n        } else if (logger == 'none') {\n            this.logger = new Logger();\n        }\n\n        this.plugins.load();\n        return this.options.read(options, OptionsReadMode.Fetch);\n    }\n\n\n    /**\n     * Return the application / root component instance.\n     */\n    get application():Application {\n        return this\n    }\n\n\n    get isCLI():boolean {\n        return false;\n    }\n\n\n    /**\n     * Return the path to the TypeScript compiler.\n     */\n    public getTypeScriptPath():string {\n        return Path.dirname(require.resolve('typescript'));\n    }\n\n\n    public getTypeScriptVersion():string {\n        var tsPath = this.getTypeScriptPath();\n        var json = JSON.parse(FS.readFileSync(Path.join(tsPath, '..', 'package.json'), 'utf8'));\n        return json.version;\n    }\n\n\n    /**\n     * Run the converter for the given set of files and return the generated reflections.\n     *\n     * @param src  A list of source that should be compiled and converted.\n     * @returns An instance of ProjectReflection on success, NULL otherwise.\n     */\n    public convert(src:string[]):ProjectReflection {\n        this.logger.writeln('Using TypeScript %s from %s', this.getTypeScriptVersion(), this.getTypeScriptPath());\n\n        var result = this.converter.convert(src);\n        if (result.errors && result.errors.length) {\n            this.logger.diagnostics(result.errors);\n            if (this.ignoreCompilerErrors) {\n                this.logger.resetErrors();\n                return result.project;\n            } else {\n                return null;\n            }\n        } else {\n            return result.project;\n        }\n    }\n\n\n    /**\n     * @param src  A list of source files whose documentation should be generated.\n     */\n    public generateDocs(src:string[], out:string):boolean;\n\n    /**\n     * @param project  The project the documentation should be generated for.\n     */\n    public generateDocs(project:ProjectReflection, out:string):boolean;\n\n    /**\n     * Run the documentation generator for the given set of files.\n     *\n     * @param out  The path the documentation should be written to.\n     * @returns TRUE if the documentation could be generated successfully, otherwise FALSE.\n     */\n    public generateDocs(input:any, out:string):boolean {\n        var project = input instanceof ProjectReflection ? input : this.convert(input);\n        if (!project) return false;\n\n        out = Path.resolve(out);\n        this.renderer.render(project, out);\n        if (this.logger.hasErrors()) {\n            this.logger.error('Documentation could not be generated due to the errors above.');\n        } else {\n            this.logger.success('Documentation generated at %s', out);\n        }\n\n        return true;\n    }\n\n\n    /**\n     * @param src  A list of source that should be compiled and converted.\n     */\n    public generateJson(src:string[], out:string):boolean;\n\n    /**\n     * @param project  The project that should be converted.\n     */\n    public generateJson(project:ProjectReflection, out:string):boolean;\n\n    /**\n     * Run the converter for the given set of files and write the reflections to a json file.\n     *\n     * @param out  The path and file name of the target file.\n     * @returns TRUE if the json file could be written successfully, otherwise FALSE.\n     */\n    public generateJson(input:any, out:string):boolean {\n        var project = input instanceof ProjectReflection ? input : this.convert(input);\n        if (!project) return false;\n\n        out = Path.resolve(out);\n        writeFile(out, JSON.stringify(project.toObject(), null, '\\t'), false);\n        this.logger.success('JSON written to %s', out);\n\n        return true;\n    }\n\n\n    /**\n     * Expand a list of input files.\n     *\n     * Searches for directories in the input files list and replaces them with a\n     * listing of all TypeScript files within them. One may use the ```--exclude``` option\n     * to filter out files with a pattern.\n     *\n     * @param inputFiles  The list of files that should be expanded.\n     * @returns  The list of input files with expanded directories.\n     */\n    public expandInputFiles(inputFiles?:string[]):string[] {\n        var exclude:IMinimatch, files:string[] = [];\n        if (this.exclude) {\n            exclude = new Minimatch(this.exclude);\n        }\n\n        function add(dirname:string) {\n            FS.readdirSync(dirname).forEach((file) => {\n                var realpath = Path.join(dirname, file);\n                if (FS.statSync(realpath).isDirectory()) {\n                    add(realpath);\n                } else if (/\\.tsx?$/.test(realpath)) {\n                    if (exclude && exclude.match(realpath.replace(/\\\\/g, '/'))) {\n                        return;\n                    }\n\n                    files.push(realpath);\n                }\n            });\n        }\n\n        inputFiles.forEach((file) => {\n            file = Path.resolve(file);\n            if (FS.statSync(file).isDirectory()) {\n                add(file);\n            } else {\n                files.push(file);\n            }\n        });\n\n        return files;\n    }\n\n\n    /**\n     * Print the version number.\n     */\n    public toString() {\n        return [\n            '',\n            'TypeDoc ' + Application.VERSION,\n            'Using TypeScript ' + this.getTypeScriptVersion() + ' from ' + this.getTypeScriptPath(),\n            ''\n        ].join(typescript.sys.newLine);\n    }\n}\n"]}