{"version":3,"file":"function.js","sourceRoot":"","sources":["../../../src/lib/converter/nodes/function.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAY,EAAE,WAAM,YAAY,CAAC,CAAA;AAEjC,sBAAyC,oBAAoB,CAAC,CAAA;AAC9D,sBAAiD,oBAAoB,CAAC,CAAA;AAEtE,0BAAwB,cAAc,CAAC,CAAA;AACvC,2BAAgD,eAAe,CAAC,CAAA;AAIhE;IAAuC,qCAAmE;IAA1G;QAAuC,8BAAmE;QAKtG,aAAQ,GAAmB;YACvB,GAA6B;YAC7B,GAA+B;YAC/B,GAAiC;SACpC,CAAC;IA4BN,CAAC;IAlBG,mCAAO,GAAP,UAAQ,OAAe,EAAE,IAAgD;QACrE,IAAI,KAAK,GAAK,OAAO,CAAC,KAAK,CAAC;QAC5B,IAAI,IAAI,GAAM,KAAK,CAAC,IAAI,GAAG,sBAAc,CAAC,gBAAgB,GAAG,sBAAc,CAAC,MAAM,GAAG,sBAAc,CAAC,QAAQ,CAAC;QAC7G,IAAI,OAAO,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,MAAM,GAAI,yBAAiB,CAAC,OAAO,EAAW,IAAI,EAAE,IAAI,CAAC,CAAC;QAE9D,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE;YACtB,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBACjC,IAAI,SAAS,GAAG,uBAAe,CAAC,OAAO,EAA2B,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,sBAAc,CAAC,aAAa,CAAC,CAAC;gBACnH,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC;oBAAC,MAAM,CAAC,UAAU,GAAG,EAAE,CAAC;gBAC/C,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACtC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,6BAA6B,EAAE,MAAM,EAAW,IAAI,CAAC,CAAC;YACpF,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IArCL;QAAC,sBAAS,CAAC,EAAC,IAAI,EAAC,eAAe,EAAC,CAAC;yBAAA;IAsClC,wBAAC;AAAD,CAAC,AArCD,CAAuC,mCAAsB,GAqC5D;AArCY,yBAAiB,oBAqC7B,CAAA","sourcesContent":["import * as ts from \"typescript\";\n\nimport {Reflection, ReflectionKind} from \"../../models/index\";\nimport {createDeclaration, createSignature} from \"../factories/index\";\nimport {Context} from \"../context\";\nimport {Converter} from \"../converter\";\nimport {Component, ConverterNodeComponent} from \"../components\";\n\n\n@Component({name:'node:function'})\nexport class FunctionConverter extends ConverterNodeComponent<ts.FunctionDeclaration|ts.MethodDeclaration>\n{\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports:ts.SyntaxKind[] = [\n        ts.SyntaxKind.MethodSignature,\n        ts.SyntaxKind.MethodDeclaration,\n        ts.SyntaxKind.FunctionDeclaration\n    ];\n\n\n    /**\n     * Analyze the given function declaration node and create a suitable reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node     The function declaration node that should be analyzed.\n     * @return The resulting reflection or NULL.\n     */\n    convert(context:Context, node:ts.FunctionDeclaration|ts.MethodDeclaration):Reflection {\n        var scope   = context.scope;\n        var kind    = scope.kind & ReflectionKind.ClassOrInterface ? ReflectionKind.Method : ReflectionKind.Function;\n        var hasBody = !!node.body;\n        var method  = createDeclaration(context, <ts.Node>node, kind);\n\n        context.withScope(method, () => {\n            if (!hasBody || !method.signatures) {\n                var signature = createSignature(context, <ts.SignatureDeclaration>node, method.name, ReflectionKind.CallSignature);\n                if (!method.signatures) method.signatures = [];\n                method.signatures.push(signature);\n            } else {\n                context.trigger(Converter.EVENT_FUNCTION_IMPLEMENTATION, method, <ts.Node>node);\n            }\n        });\n\n        return method;\n    }\n}\n"]}