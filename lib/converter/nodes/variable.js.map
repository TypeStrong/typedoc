{"version":3,"file":"variable.js","sourceRoot":"","sources":["../../../src/lib/converter/nodes/variable.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\n\nimport {Reflection, ReflectionKind, IntrinsicType} from \"../../models/index\";\nimport {createDeclaration, createComment} from \"../factories/index\";\nimport {Context} from \"../context\";\nimport {Component, ConverterNodeComponent} from \"../components\";\nimport {convertDefaultValue} from \"../index\";\n\n\n@Component({name:'node:variable'})\nexport class VariableConverter extends ConverterNodeComponent<ts.VariableDeclaration>\n{\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports:ts.SyntaxKind[] = [\n        ts.SyntaxKind.PropertySignature,\n        ts.SyntaxKind.PropertyDeclaration,\n        ts.SyntaxKind.PropertyAssignment,\n        ts.SyntaxKind.ShorthandPropertyAssignment,\n        ts.SyntaxKind.VariableDeclaration,\n        ts.SyntaxKind.BindingElement\n    ];\n\n\n    isSimpleObjectLiteral(objectLiteral:ts.ObjectLiteralExpression):boolean {\n        if (!objectLiteral.properties) return true;\n        return objectLiteral.properties.length == 0;\n    }\n\n\n    /**\n     * Analyze the given variable declaration node and create a suitable reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node     The variable declaration node that should be analyzed.\n     * @return The resulting reflection or NULL.\n     */\n    convert(context:Context, node:ts.VariableDeclaration):Reflection {\n        var comment = createComment(node);\n        if (comment && comment.hasTag(\"resolve\")) {\n            var resolveType = context.getTypeAtLocation(node);\n            if (resolveType && resolveType.symbol) {\n                var resolved = this.owner.convertNode(context, resolveType.symbol.declarations[0]);\n                if (resolved) {\n                    resolved.name = node.symbol.name;\n                }\n                return resolved;\n            }\n        }\n\n        var name:string, isBindingPattern:boolean;\n        if (ts.isBindingPattern(node.name)) {\n            if (node['propertyName']) {\n                name = ts.declarationNameToString(node['propertyName']);\n                isBindingPattern = true;\n            } else {\n                return null;\n            }\n        }\n\n        var scope = context.scope;\n        var kind = scope.kind & ReflectionKind.ClassOrInterface ? ReflectionKind.Property : ReflectionKind.Variable;\n        var variable = createDeclaration(context, node, kind, name);\n        context.withScope(variable, () => {\n            if (node.initializer) {\n                switch (node.initializer.kind) {\n                    case ts.SyntaxKind.ArrowFunction:\n                    case ts.SyntaxKind.FunctionExpression:\n                        variable.kind = scope.kind & ReflectionKind.ClassOrInterface ? ReflectionKind.Method : ReflectionKind.Function;\n                        this.owner.convertNode(context, node.initializer);\n                        break;\n                    case ts.SyntaxKind.ObjectLiteralExpression:\n                        if (!this.isSimpleObjectLiteral(<ts.ObjectLiteralExpression>node.initializer)) {\n                            variable.kind = ReflectionKind.ObjectLiteral;\n                            variable.type = new IntrinsicType('object');\n                            this.owner.convertNode(context, node.initializer);\n                        }\n                        break;\n                    default:\n                        variable.defaultValue = convertDefaultValue(node);\n                }\n            }\n\n            if (variable.kind == kind || variable.kind == ReflectionKind.Event) {\n                if (isBindingPattern) {\n                    variable.type = this.owner.convertType(context, node.name);\n                } else {\n                    variable.type = this.owner.convertType(context, node.type, context.getTypeAtLocation(node));\n                }\n            }\n        });\n\n        return variable;\n    }\n}\n"]}