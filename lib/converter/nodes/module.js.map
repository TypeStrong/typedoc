{"version":3,"file":"module.js","sourceRoot":"","sources":["../../../src/lib/converter/nodes/module.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAY,EAAE,WAAM,YAAY,CAAC,CAAA;AAEjC,sBAA4E,oBAAoB,CAAC,CAAA;AACjG,sBAAgC,oBAAoB,CAAC,CAAA;AAErD,2BAAgD,eAAe,CAAC,CAAA;AAIhE;IAAqC,mCAA4C;IAAjF;QAAqC,8BAA4C;QAK7E,aAAQ,GAAmB;YACvB,GAA+B;SAClC,CAAC;IA4BN,CAAC;IAlBG,iCAAO,GAAP,UAAQ,OAAe,EAAE,IAAyB;QAAlD,iBAiBC;QAhBG,IAAI,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC;QAC3B,IAAI,UAAU,GAAG,yBAAiB,CAAC,OAAO,EAAE,IAAI,EAAE,sBAAc,CAAC,MAAM,CAAC,CAAC;QAEzE,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE;YAC1B,IAAI,GAAG,GAAG,OAAO,CAAC,kBAAkB,EAAE,CAAC;YACvC,EAAE,CAAC,CAAC,MAAM,YAAY,yBAAiB,IAAI,CAAC,OAAO,CAAC,aAAa;gBAC7D,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;gBACjE,UAAU,CAAC,OAAO,CAAC,sBAAc,CAAC,QAAQ,CAAC,CAAC;YAChD,CAAC;YAED,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBACZ,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YAC/C,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAnCL;QAAC,sBAAS,CAAC,EAAC,IAAI,EAAC,aAAa,EAAC,CAAC;uBAAA;IAoChC,sBAAC;AAAD,CAAC,AAnCD,CAAqC,mCAAsB,GAmC1D;AAnCY,uBAAe,kBAmC3B,CAAA","sourcesContent":["import * as ts from \"typescript\";\n\nimport {Reflection, ReflectionKind, ReflectionFlag, ProjectReflection} from \"../../models/index\";\nimport {createDeclaration} from \"../factories/index\";\nimport {Context} from \"../context\";\nimport {Component, ConverterNodeComponent} from \"../components\";\n\n\n@Component({name:'node:module'})\nexport class ModuleConverter extends ConverterNodeComponent<ts.ModuleDeclaration>\n{\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports:ts.SyntaxKind[] = [\n        ts.SyntaxKind.ModuleDeclaration\n    ];\n\n\n    /**\n     * Analyze the given module node and create a suitable reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node     The module node that should be analyzed.\n     * @return The resulting reflection or NULL.\n     */\n    convert(context:Context, node:ts.ModuleDeclaration):Reflection {\n        var parent = context.scope;\n        var reflection = createDeclaration(context, node, ReflectionKind.Module);\n\n        context.withScope(reflection, () => {\n            var opt = context.getCompilerOptions();\n            if (parent instanceof ProjectReflection && !context.isDeclaration &&\n                (!module || module.valueOf() === ts.ModuleKind.None.valueOf())) {\n                reflection.setFlag(ReflectionFlag.Exported);\n            }\n\n            if (node.body) {\n                this.owner.convertNode(context, node.body);\n            }\n        });\n\n        return reflection;\n    }\n}\n"]}