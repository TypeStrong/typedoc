{"version":3,"file":"context.js","sourceRoot":"","sources":["../../src/lib/converter/context.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport {Minimatch, IMinimatch} from \"minimatch\";\n\nimport {Logger} from \"../utils/loggers\";\nimport {Reflection, ProjectReflection, ContainerReflection, Type} from \"../models/index\";\nimport {createTypeParameter} from \"./factories/type-parameter\";\nimport {Converter} from \"./converter\";\n\n\n/**\n * The context describes the current state the converter is in.\n */\nexport class Context\n{\n    /**\n     * The converter instance that has created the context.\n     */\n    converter:Converter;\n\n    /**\n     * A list of all files that have been passed to the TypeScript compiler.\n     */\n    fileNames:string[];\n\n    /**\n     * The TypeChecker instance returned by the TypeScript compiler.\n     */\n    checker:ts.TypeChecker;\n\n    /**\n     * The program that is currently processed.\n     */\n    program:ts.Program;\n\n    /**\n     * The project that is currently processed.\n     */\n    project:ProjectReflection;\n\n    /**\n     * The scope or parent reflection that is currently processed.\n     */\n    scope:Reflection;\n\n    /**\n     * Is the current source file marked as being external?\n     */\n    isExternal:boolean;\n\n    /**\n     * Is the current source file a declaration file?\n     */\n    isDeclaration:boolean;\n\n    /**\n     * The currently set type parameters.\n     */\n    typeParameters:ts.MapLike<Type>;\n\n    /**\n     * The currently set type arguments.\n     */\n    typeArguments:Type[];\n\n    /**\n     * Is the converter in inheritance mode?\n     */\n    isInherit:boolean;\n\n    /**\n     * The node that has started the inheritance mode.\n     */\n    inheritParent:ts.Node;\n\n    /**\n     * List symbol ids of inherited children already visited while inheriting.\n     */\n    inheritedChildren:number[];\n\n    /**\n     * The names of the children of the scope before inheritance has been started.\n     */\n    inherited:string[];\n\n    /**\n     * A list of parent nodes that have been passed to the visit function.\n     */\n    visitStack:ts.Node[];\n\n    /**\n     * Next free symbol id used by [[getSymbolID]].\n     */\n    private symbolID:number = -1024;\n\n    /**\n     * The pattern that should be used to flag external source files.\n     */\n    private externalPattern:IMinimatch;\n\n\n\n    /**\n     * Create a new Context instance.\n     *\n     * @param converter  The converter instance that has created the context.\n     * @param fileNames  A list of all files that have been passed to the TypeScript compiler.\n     * @param checker  The TypeChecker instance returned by the TypeScript compiler.\n     */\n    constructor(converter:Converter, fileNames:string[], checker:ts.TypeChecker, program:ts.Program) {\n        this.converter = converter;\n        this.fileNames = fileNames;\n        this.checker = checker;\n        this.program = program;\n        this.visitStack = [];\n\n        var project = new ProjectReflection(converter.name);\n        this.project = project;\n        this.scope = project;\n\n        if (converter.externalPattern) {\n            this.externalPattern = new Minimatch(converter.externalPattern);\n        }\n    }\n\n\n    /**\n     * Return the compiler options.\n     */\n    getCompilerOptions():ts.CompilerOptions {\n        return this.converter.application.options.getCompilerOptions();\n    }\n\n\n    /**\n     * Return the type declaration of the given node.\n     *\n     * @param node  The TypeScript node whose type should be resolved.\n     * @returns The type declaration of the given node.\n     */\n    getTypeAtLocation(node:ts.Node):ts.Type {\n        try {\n            return this.checker.getTypeAtLocation(node);\n        } catch (error) {\n            try {\n                if (node.symbol) {\n                    return this.checker.getDeclaredTypeOfSymbol(node.symbol);\n                }\n            } catch (error) {}\n        }\n\n        return null;\n    }\n\n\n    /**\n     * Return the current logger instance.\n     *\n     * @returns The current logger instance.\n     */\n    getLogger():Logger {\n        return this.converter.application.logger;\n    }\n\n\n    /**\n     * Return the symbol id of the given symbol.\n     *\n     * The compiler sometimes does not assign an id to symbols, this method makes sure that we have one.\n     * It will assign negative ids if they are not set.\n     *\n     * @param symbol  The symbol whose id should be returned.\n     * @returns The id of the given symbol.\n     */\n    getSymbolID(symbol:ts.Symbol):number {\n        if (!symbol) return null;\n        if (!symbol.id) symbol.id = this.symbolID--;\n        return symbol.id;\n    }\n\n\n    /**\n     * Register a newly generated reflection.\n     *\n     * Ensures that the reflection is both listed in [[Project.reflections]] and\n     * [[Project.symbolMapping]] if applicable.\n     *\n     * @param reflection  The reflection that should be registered.\n     * @param node  The node the given reflection was resolved from.\n     * @param symbol  The symbol the given reflection was resolved from.\n     */\n    registerReflection(reflection:Reflection, node:ts.Node, symbol?:ts.Symbol) {\n        this.project.reflections[reflection.id] = reflection;\n\n        var id = this.getSymbolID(symbol ? symbol : (node ? node.symbol : null));\n        if (!this.isInherit && id && !this.project.symbolMapping[id]) {\n            this.project.symbolMapping[id] = reflection.id;\n        }\n    }\n\n\n    /**\n     * Trigger a node reflection event.\n     *\n     * All events are dispatched on the current converter instance.\n     *\n     * @param name  The name of the event that should be triggered.\n     * @param reflection  The triggering reflection.\n     * @param node  The triggering TypeScript node if available.\n     */\n    trigger(name:string, reflection:Reflection, node?:ts.Node) {\n        this.converter.trigger(name, this, reflection, node);\n    }\n\n\n    /**\n     * Run the given callback with the context configured for the given source file.\n     *\n     * @param node  The TypeScript node containing the source file declaration.\n     * @param callback  The callback that should be executed.\n     */\n    withSourceFile(node:ts.SourceFile, callback:Function) {\n        var options = this.converter.application.options;\n        var externalPattern = this.externalPattern;\n        var isExternal = this.fileNames.indexOf(node.fileName) == -1;\n        if (externalPattern) {\n            isExternal = isExternal || externalPattern.match(node.fileName);\n        }\n\n        if (isExternal && this.converter.excludeExternals) {\n            return;\n        }\n\n        var isDeclaration = ts.isDeclarationFile(node);\n        if (isDeclaration) {\n            var lib = this.converter.getDefaultLib();\n            var isLib = node.fileName.substr(-lib.length) == lib;\n            if (!this.converter.includeDeclarations || isLib) {\n                return;\n            }\n        }\n\n        this.isExternal = isExternal;\n        this.isDeclaration = isDeclaration;\n\n        this.trigger(Converter.EVENT_FILE_BEGIN, this.project, node);\n        callback();\n\n        this.isExternal = false;\n        this.isDeclaration = false;\n    }\n\n\n    /**\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope:Reflection, callback:Function):void;\n\n    /**\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope:Reflection, parameters:ts.NodeArray<ts.TypeParameterDeclaration>, callback:Function):void;\n\n    /**\n     * @param parameters  An array of type parameters that should be set on the context while the callback is invoked.\n     * @param preserve  Should the currently set type parameters of the context be preserved?\n     * @param callback  The callback function that should be executed with the changed context.\n     */\n    public withScope(scope:Reflection, parameters:ts.NodeArray<ts.TypeParameterDeclaration>, preserve:boolean, callback:Function):void;\n\n    /**\n     * Run the given callback with the scope of the context set to the given reflection.\n     *\n     * @param scope  The reflection that should be set as the scope of the context while the callback is invoked.\n     */\n    public withScope(scope:Reflection, ...args:any[]):void {\n        if (!scope || !args.length) return;\n        var callback = args.pop();\n        var parameters = args.shift();\n\n        var oldScope = this.scope;\n        var oldTypeArguments = this.typeArguments;\n        var oldTypeParameters = this.typeParameters;\n\n        this.scope = scope;\n        this.typeParameters = parameters ? this.extractTypeParameters(parameters, args.length > 0) : this.typeParameters;\n        this.typeArguments = null;\n\n        callback();\n\n        this.scope = oldScope;\n        this.typeParameters = oldTypeParameters;\n        this.typeArguments = oldTypeArguments;\n    }\n\n\n    /**\n     * Inherit the children of the given TypeScript node to the current scope.\n     *\n     * @param baseNode  The node whose children should be inherited.\n     * @param typeArguments  The type arguments that apply while inheriting the given node.\n     * @return The resulting reflection / the current scope.\n     */\n    inherit(baseNode:ts.Node, typeArguments?:ts.NodeArray<ts.TypeNode>):Reflection {\n        var wasInherit = this.isInherit;\n        var oldInherited = this.inherited;\n        var oldInheritParent = this.inheritParent;\n        var oldTypeArguments = this.typeArguments;\n\n        this.isInherit = true;\n        this.inheritParent = baseNode;\n        this.inherited = [];\n\n        var target = <ContainerReflection>this.scope;\n        if (!(target instanceof ContainerReflection)) {\n            throw new Error('Expected container reflection');\n        }\n\n        if (baseNode.symbol) {\n            var id = this.getSymbolID(baseNode.symbol);\n            if (this.inheritedChildren && this.inheritedChildren.indexOf(id) != -1) {\n                return target;\n            } else {\n                this.inheritedChildren = this.inheritedChildren || [];\n                this.inheritedChildren.push(id);\n            }\n        }\n\n        if (target.children) {\n            this.inherited = target.children.map((c) => c.name);\n        } else {\n            this.inherited = [];\n        }\n\n        if (typeArguments) {\n            this.typeArguments = typeArguments.map((t) => this.converter.convertType(this, t));\n        } else {\n            this.typeArguments = null;\n        }\n\n        this.converter.convertNode(this, baseNode);\n\n        this.isInherit = wasInherit;\n        this.inherited = oldInherited;\n        this.inheritParent = oldInheritParent;\n        this.typeArguments = oldTypeArguments;\n\n        if (!this.isInherit) {\n            delete this.inheritedChildren;\n        }\n\n        return target;\n    }\n\n\n    /**\n     * Convert the given list of type parameter declarations into a type mapping.\n     *\n     * @param parameters  The list of type parameter declarations that should be converted.\n     * @param preserve  Should the currently set type parameters of the context be preserved?\n     * @returns The resulting type mapping.\n     */\n    private extractTypeParameters(parameters:ts.NodeArray<ts.TypeParameterDeclaration>, preserve?:boolean):ts.MapLike<Type> {\n        var typeParameters:ts.MapLike<Type> = {};\n\n        if (preserve) {\n            for (var key in this.typeParameters) {\n                if (!this.typeParameters.hasOwnProperty(key)) continue;\n                typeParameters[key] = this.typeParameters[key];\n            }\n        }\n\n        parameters.forEach((declaration:ts.TypeParameterDeclaration, index:number) => {\n            var name = declaration.symbol.name;\n            if (this.typeArguments && this.typeArguments[index]) {\n                typeParameters[name] = this.typeArguments[index];\n            } else {\n                typeParameters[name] = createTypeParameter(this, declaration);\n            }\n        });\n\n        return typeParameters;\n    }\n}\n"]}