{"version":3,"file":"converter.js","sourceRoot":"","sources":["../../src/lib/converter/converter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport * as Path from \"path\";\n\nimport {Application} from \"../application\";\nimport {ParameterType} from \"../utils/options/declaration\";\nimport {Reflection, Type, ProjectReflection} from \"../models/index\";\nimport {Context} from \"./context\";\nimport {ConverterComponent, ConverterNodeComponent, ConverterTypeComponent, ITypeTypeConverter, ITypeNodeConverter} from \"./components\";\nimport {CompilerHost} from \"./utils/compiler-host\";\nimport {Component, Option, ChildableComponent, IComponentClass} from \"../utils/component\"\n\n\n/**\n * Result structure of the [[Converter.convert]] method.\n */\nexport interface IConverterResult\n{\n    /**\n     * An array containing all errors generated by the TypeScript compiler.\n     */\n    errors:ts.Diagnostic[];\n\n    /**\n     * The resulting project reflection.\n     */\n    project:ProjectReflection;\n}\n\n\n/**\n * Event callback definition for generic converter events.\n *\n * @see [[Converter.EVENT_BEGIN]]\n * @see [[Converter.EVENT_END]]\n * @see [[Converter.EVENT_RESOLVE_BEGIN]]\n * @see [[Converter.EVENT_RESOLVE_END]]\n */\ninterface IConverterCallback\n{\n    /**\n     * @param context  The context object describing the current state the converter is in.\n     */\n    (context:Context):void;\n}\n\n\n/**\n * Event callback definition for events triggered by factories.\n *\n * @see [[Converter.EVENT_FILE_BEGIN]]\n * @see [[Converter.EVENT_CREATE_DECLARATION]]\n * @see [[Converter.EVENT_CREATE_SIGNATURE]]\n * @see [[Converter.EVENT_CREATE_PARAMETER]]\n * @see [[Converter.EVENT_CREATE_TYPE_PARAMETER]]\n * @see [[Converter.EVENT_FUNCTION_IMPLEMENTATION]]\n */\ninterface IConverterNodeCallback\n{\n    /**\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    (context:Context, reflection:Reflection, node?:ts.Node):void;\n}\n\n\n/**\n * Event callback definition for events during the resolving phase.\n *\n * @see [[Converter.EVENT_RESOLVE]]\n */\ninterface IConverterResolveCallback\n{\n    /**\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    (context:Context, reflection:Reflection):void;\n}\n\n\n/**\n * Compiles source files using TypeScript and converts compiler symbols to reflections.\n */\n@Component({name:\"converter\", internal:true, childClass:ConverterComponent})\nexport class Converter extends ChildableComponent<Application, ConverterComponent>\n{\n    /**\n     * The human readable name of the project. Used within the templates to set the title of the document.\n     */\n    @Option({\n        name: \"name\",\n        help: \"Set the name of the project that will be used in the header of the template.\"\n    })\n    name:string;\n\n    @Option({\n        name: \"externalPattern\",\n        help: 'Define a pattern for files that should be considered being external.'\n    })\n    externalPattern:string;\n\n    @Option({\n        name: \"includeDeclarations\",\n        help: 'Turn on parsing of .d.ts declaration files.',\n        type: ParameterType.Boolean\n    })\n    includeDeclarations:boolean;\n\n    @Option({\n        name: \"excludeExternals\",\n        help: 'Prevent externally resolved TypeScript files from being documented.',\n        type: ParameterType.Boolean\n    })\n    excludeExternals:boolean;\n\n    @Option({\n        name: \"excludeNotExported\",\n        help: 'Prevent symbols that are not exported from being documented.',\n        type: ParameterType.Boolean\n    })\n    excludeNotExported:boolean;\n\n    @Option({\n        name: \"excludePrivate\",\n        help: 'Ignores private variables and methods',\n        type: ParameterType.Boolean\n    })\n    excludePrivate:boolean;\n\n    private compilerHost:CompilerHost;\n\n    private nodeConverters:{[syntaxKind:number]:ConverterNodeComponent<ts.Node>};\n\n    private typeNodeConverters:ITypeNodeConverter<ts.Type, ts.Node>[];\n\n    private typeTypeConverters:ITypeTypeConverter<ts.Type>[];\n\n\n    /**\n     * General events\n     */\n\n    /**\n     * Triggered when the converter begins converting a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_BEGIN:string = 'begin';\n\n    /**\n     * Triggered when the converter has finished converting a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_END:string = 'end';\n\n\n    /**\n     * Factory events\n     */\n\n    /**\n     * Triggered when the converter begins converting a source file.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_FILE_BEGIN:string = 'fileBegin';\n\n    /**\n     * Triggered when the converter has created a declaration reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_DECLARATION:string = 'createDeclaration';\n\n    /**\n     * Triggered when the converter has created a signature reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_SIGNATURE:string = 'createSignature';\n\n    /**\n     * Triggered when the converter has created a parameter reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_PARAMETER:string = 'createParameter';\n\n    /**\n     * Triggered when the converter has created a type parameter reflection.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_CREATE_TYPE_PARAMETER:string = 'createTypeParameter';\n\n    /**\n     * Triggered when the converter has found a function implementation.\n     * The listener should implement [[IConverterNodeCallback]].\n     * @event\n     */\n    static EVENT_FUNCTION_IMPLEMENTATION:string = 'functionImplementation';\n\n\n    /**\n     * Resolve events\n     */\n\n    /**\n     * Triggered when the converter begins resolving a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_RESOLVE_BEGIN:string = 'resolveBegin';\n\n    /**\n     * Triggered when the converter resolves a reflection.\n     * The listener should implement [[IConverterResolveCallback]].\n     * @event\n     */\n    static EVENT_RESOLVE:string = 'resolveReflection';\n\n    /**\n     * Triggered when the converter has finished resolving a project.\n     * The listener should implement [[IConverterCallback]].\n     * @event\n     */\n    static EVENT_RESOLVE_END:string = 'resolveEnd';\n\n\n\n    /**\n     * Create a new Converter instance.\n     *\n     * @param application  The application instance this converter relies on. The application\n     *   must expose the settings that should be used and serves as a global logging endpoint.\n     */\n    initialize() {\n        this.compilerHost = new CompilerHost(this);\n        this.nodeConverters = {};\n        this.typeTypeConverters = [];\n        this.typeNodeConverters = [];\n    }\n\n\n    addComponent(name:string, componentClass:IComponentClass<ConverterComponent>):ConverterComponent {\n        var component = super.addComponent(name, componentClass);\n        if (component instanceof ConverterNodeComponent) {\n            this.addNodeConverter(component);\n        } else if (component instanceof ConverterTypeComponent) {\n            this.addTypeConverter(<ITypeTypeConverter<any>|ITypeNodeConverter<any, any>>component);\n        }\n\n        return component;\n    }\n\n\n    private addNodeConverter(converter:ConverterNodeComponent<any>) {\n        for (var supports of converter.supports) {\n            this.nodeConverters[supports] = converter;\n        }\n    }\n\n\n    private addTypeConverter(converter:ITypeTypeConverter<any>|ITypeNodeConverter<any, any>) {\n        if (\"supportsNode\" in converter && \"convertNode\" in converter) {\n            this.typeNodeConverters.push(<ITypeNodeConverter<any, any>>converter);\n            this.typeNodeConverters.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n        }\n\n        if (\"supportsType\" in converter && \"convertType\" in converter) {\n            this.typeTypeConverters.push(<ITypeTypeConverter<any>>converter);\n            this.typeTypeConverters.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n        }\n    }\n\n\n    removeComponent(name:string):ConverterComponent {\n        var component = super.removeComponent(name);\n        if (component instanceof ConverterNodeComponent) {\n            this.removeNodeConverter(component);\n        } else if (component instanceof ConverterTypeComponent) {\n            this.removeTypeConverter(component);\n        }\n\n        return component;\n    }\n\n\n    private removeNodeConverter(converter:ConverterNodeComponent<any>) {\n        var converters = this.nodeConverters;\n        var keys = _.keys(this.nodeConverters);\n        for (var key of keys) {\n            if (converters[key] === converter) {\n                delete converters[key];\n            }\n        }\n    }\n\n\n    private removeTypeConverter(converter:ConverterTypeComponent) {\n        var index = this.typeNodeConverters.indexOf(<any>converter);\n        if (index != -1) {\n            this.typeTypeConverters.splice(index, 1);\n        }\n\n        index = this.typeNodeConverters.indexOf(<any>converter);\n        if (index != -1) {\n            this.typeNodeConverters.splice(index, 1);\n        }\n    }\n\n\n    removeAllComponents() {\n        super.removeAllComponents();\n\n        this.nodeConverters = {};\n        this.typeTypeConverters = [];\n        this.typeNodeConverters = [];\n    }\n\n\n\n    /**\n     * Compile the given source files and create a project reflection for them.\n     *\n     * @param fileNames  Array of the file names that should be compiled.\n     */\n    convert(fileNames:string[]):IConverterResult {\n        for (var i = 0, c = fileNames.length; i < c; i++) {\n            fileNames[i] = ts.normalizePath(ts.normalizeSlashes(fileNames[i]));\n        }\n\n        var program = ts.createProgram(fileNames, this.application.options.getCompilerOptions(), this.compilerHost);\n        var checker = program.getTypeChecker();\n        var context = new Context(this, fileNames, checker, program);\n\n        this.trigger(Converter.EVENT_BEGIN, context);\n\n        var errors = this.compile(context);\n        var project = this.resolve(context);\n\n        this.trigger(Converter.EVENT_END, context);\n\n        return {\n            errors: errors,\n            project: project\n        }\n    }\n\n\n    /**\n     * Analyze the given node and create a suitable reflection.\n     *\n     * This function checks the kind of the node and delegates to the matching function implementation.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node     The compiler node that should be analyzed.\n     * @return The resulting reflection or NULL.\n     */\n    convertNode(context:Context, node:ts.Node):Reflection {\n        if (context.visitStack.indexOf(node) != -1) {\n            return null;\n        }\n\n        var oldVisitStack = context.visitStack;\n        context.visitStack = oldVisitStack.slice();\n        context.visitStack.push(node);\n\n        var result:Reflection;\n        if (node.kind in this.nodeConverters) {\n            result = this.nodeConverters[node.kind].convert(context, node);\n        }\n\n        context.visitStack = oldVisitStack;\n        return result;\n    }\n\n\n    /**\n     * Convert the given TypeScript type into its TypeDoc type reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The node whose type should be reflected.\n     * @param type  The type of the node if already known.\n     * @returns The TypeDoc type reflection representing the given node and type.\n     */\n    convertType(context:Context, node?:ts.Node, type?:ts.Type):Type {\n        // Run all node based type conversions\n        if (node) {\n            type = type || context.getTypeAtLocation(node);\n\n            for (let converter of this.typeNodeConverters) {\n                if (converter.supportsNode(context, node, type)) {\n                    return converter.convertNode(context, node, type);\n                }\n            }\n        }\n\n        // Run all type based type conversions\n        if (type) {\n            for (let converter of this.typeTypeConverters) {\n                if (converter.supportsType(context, type)) {\n                    return converter.convertType(context, type);\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Compile the files within the given context and convert the compiler symbols to reflections.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns An array containing all errors generated by the TypeScript compiler.\n     */\n    private compile(context:Context):ts.Diagnostic[] {\n        var program = context.program;\n\n        program.getSourceFiles().forEach((sourceFile) => {\n            this.convertNode(context, sourceFile);\n        });\n        \n        let diagnostics = program.getOptionsDiagnostics();\n        if (diagnostics.length) return diagnostics;\n        \n        diagnostics = program.getSyntacticDiagnostics();\n        if (diagnostics.length) return diagnostics;\n        \n        diagnostics = program.getGlobalDiagnostics();\n        if (diagnostics.length) return diagnostics;\n\n        diagnostics = program.getSemanticDiagnostics();\n        if (diagnostics.length) return diagnostics;\n        \n        return [];\n    }\n\n\n    /**\n     * Resolve the project within the given context.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns The final project reflection.\n     */\n    private resolve(context:Context):ProjectReflection {\n        this.trigger(Converter.EVENT_RESOLVE_BEGIN, context);\n        var project = context.project;\n\n        for (var id in project.reflections) {\n            if (!project.reflections.hasOwnProperty(id)) continue;\n            this.trigger(Converter.EVENT_RESOLVE, context, project.reflections[id]);\n        }\n\n        this.trigger(Converter.EVENT_RESOLVE_END, context);\n        return project;\n    }\n\n\n    /**\n     * Return the basename of the default library that should be used.\n     *\n     * @returns The basename of the default library.\n     */\n    getDefaultLib():string {\n        return ts.getDefaultLibFileName(this.application.options.getCompilerOptions());\n    }\n}\n"]}