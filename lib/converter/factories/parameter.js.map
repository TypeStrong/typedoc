{"version":3,"file":"parameter.js","sourceRoot":"","sources":["../../../src/lib/converter/factories/parameter.ts"],"names":[],"mappings":";AAAA,IAAY,EAAE,WAAM,YAAY,CAAC,CAAA;AAEjC,sBAAuF,gCAAgC,CAAC,CAAA;AAExH,0BAAwB,cAAc,CAAC,CAAA;AACvC,mCAAkC,uBAAuB,CAAC,CAAA;AAU1D,yBAAgC,OAAe,EAAE,IAA4B;IACzE,IAAI,SAAS,GAAwB,OAAO,CAAC,KAAK,CAAC;IACnD,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,YAAY,2BAAmB,CAAC,CAAC,CAAC,CAAC;QAC9C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAED,IAAI,SAAS,GAAG,IAAI,2BAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,sBAAc,CAAC,SAAS,CAAC,CAAC;IAC/F,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE;QACzB,EAAE,CAAC,CAAC,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACjC,SAAS,CAAC,IAAI,GAAG,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YACnE,SAAS,CAAC,IAAI,GAAG,mBAAmB,CAAA;QACxC,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,SAAS,CAAC,IAAI,GAAG,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;QACxG,CAAC;QAED,SAAS,CAAC,YAAY,GAAG,wCAAmB,CAAC,IAAI,CAAC,CAAC;QACnD,SAAS,CAAC,OAAO,CAAC,sBAAc,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACjE,SAAS,CAAC,OAAO,CAAC,sBAAc,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC9D,SAAS,CAAC,OAAO,CAAC,sBAAc,CAAC,YAAY,EAAE,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QAEzE,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;YAAC,SAAS,CAAC,UAAU,GAAG,EAAE,CAAC;QACrD,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,sBAAsB,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACnE,MAAM,CAAC,SAAS,CAAC;AACrB,CAAC;AA3Be,uBAAe,kBA2B9B,CAAA","sourcesContent":["import * as ts from \"typescript\";\n\nimport {ReflectionFlag, ReflectionKind, ParameterReflection, SignatureReflection} from \"../../models/reflections/index\";\nimport {Context} from \"../context\";\nimport {Converter} from \"../converter\";\nimport {convertDefaultValue} from \"../convert-expression\";\n\n\n/**\n * Create a parameter reflection for the given node.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The parameter node that should be reflected.\n * @returns The newly created parameter reflection.\n */\nexport function createParameter(context:Context, node:ts.ParameterDeclaration):ParameterReflection {\n    var signature = <SignatureReflection>context.scope;\n    if (!(signature instanceof SignatureReflection)) {\n        throw new Error('Expected signature reflection.');\n    }\n\n    var parameter = new ParameterReflection(signature, node.symbol.name, ReflectionKind.Parameter);\n    context.registerReflection(parameter, node);\n    context.withScope(parameter, () => {\n        if (ts.isBindingPattern(node.name)) {\n            parameter.type = context.converter.convertType(context, node.name);\n            parameter.name = '__namedParameters'\n        } else {\n            parameter.type = context.converter.convertType(context, node.type, context.getTypeAtLocation(node));\n        }\n\n        parameter.defaultValue = convertDefaultValue(node);\n        parameter.setFlag(ReflectionFlag.Optional, !!node.questionToken);\n        parameter.setFlag(ReflectionFlag.Rest, !!node.dotDotDotToken);\n        parameter.setFlag(ReflectionFlag.DefaultValue, !!parameter.defaultValue);\n\n        if (!signature.parameters) signature.parameters = [];\n        signature.parameters.push(parameter);\n    });\n\n    context.trigger(Converter.EVENT_CREATE_PARAMETER, parameter, node);\n    return parameter;\n}\n"]}