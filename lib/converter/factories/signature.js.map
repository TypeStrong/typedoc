{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../src/lib/converter/factories/signature.ts"],"names":[],"mappings":";AAAA,IAAY,EAAE,WAAM,YAAY,CAAC,CAAA;AAEjC,sBAAoG,oBAAoB,CAAC,CAAA;AAEzH,0BAAwB,cAAc,CAAC,CAAA;AACvC,0BAA8B,aAAa,CAAC,CAAA;AAC5C,0BAAkC,aAAa,CAAC,CAAA;AAYhD,yBAAgC,OAAe,EAAE,IAA4B,EAAE,IAAW,EAAE,IAAmB;IAC3G,IAAI,SAAS,GAA0B,OAAO,CAAC,KAAK,CAAC;IACrD,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,YAAY,2BAAmB,CAAC,CAAC,CAAC,CAAC;QAC9C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAED,IAAI,SAAS,GAAG,IAAI,2BAAmB,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAC/D,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE;QACpD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,SAAiC;YACtD,2BAAe,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC,IAAI,GAAG,oBAAoB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAErD,EAAE,CAAC,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;YAC1B,SAAS,CAAC,aAAa,GAAG,+BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC9E,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,sBAAsB,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACnE,MAAM,CAAC,SAAS,CAAC;AACrB,CAAC;AAtBe,uBAAe,kBAsB9B,CAAA;AAYD,8BAA8B,OAAe,EAAE,IAA4B;IACvE,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAC9B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,GAA2B,IAAI,IAAI,CAAC,IAAI,GAAG,GAA4B,CAAC,CAAC,CAAC;QACtF,IAAI,CAAC;YACD,IAAI,SAAS,GAAG,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;YAC1D,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1G,CAAE;QAAA,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA,CAAC;IACtB,CAAC;IAED,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACZ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7D,CAAC;IAAC,IAAI,CAAC,CAAC;QACJ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACxD,CAAC;AACL,CAAC","sourcesContent":["import * as ts from \"typescript\";\n\nimport {ReflectionKind, SignatureReflection, ContainerReflection, DeclarationReflection, Type} from \"../../models/index\";\nimport {Context} from \"../context\";\nimport {Converter} from \"../converter\";\nimport {createParameter} from \"./parameter\";\nimport {createReferenceType} from \"./reference\";\n\n\n/**\n * Create a new signature reflection from the given node.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The TypeScript node containing the signature declaration that should be reflected.\n * @param name  The name of the function or method this signature belongs to.\n * @param kind  The desired kind of the reflection.\n * @returns The newly created signature reflection describing the given node.\n */\nexport function createSignature(context:Context, node:ts.SignatureDeclaration, name:string, kind:ReflectionKind):SignatureReflection {\n    var container = <DeclarationReflection>context.scope;\n    if (!(container instanceof ContainerReflection)) {\n        throw new Error('Expected container reflection.');\n    }\n\n    var signature = new SignatureReflection(container, name, kind);\n    context.registerReflection(signature, node);\n    context.withScope(signature, node.typeParameters, true, () => {\n        node.parameters.forEach((parameter:ts.ParameterDeclaration) => {\n            createParameter(context, parameter);\n        });\n\n        signature.type = extractSignatureType(context, node);\n\n        if (container.inheritedFrom) {\n            signature.inheritedFrom = createReferenceType(context, node.symbol, true);\n        }\n    });\n\n    context.trigger(Converter.EVENT_CREATE_SIGNATURE, signature, node);\n    return signature;\n}\n\n\n\n\n/**\n * Extract the return type of the given signature declaration.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param node  The signature declaration whose return type should be determined.\n * @returns The return type reflection of the given signature.\n */\nfunction extractSignatureType(context:Context, node:ts.SignatureDeclaration):Type {\n    var checker = context.checker;\n    if (node.kind & ts.SyntaxKind.CallSignature || node.kind & ts.SyntaxKind.CallExpression) {\n        try {\n            var signature = checker.getSignatureFromDeclaration(node);\n            return context.converter.convertType(context, node.type, checker.getReturnTypeOfSignature(signature));\n        } catch (error) {}\n    }\n\n    if (node.type) {\n        return context.converter.convertType(context, node.type);\n    } else {\n        return context.converter.convertType(context, node);\n    }\n}\n"]}