{"version":3,"file":"comment.js","sourceRoot":"","sources":["../../../src/lib/converter/factories/comment.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\n\nimport {Comment, CommentTag} from \"../../models/comments/index\";\n\n\n/**\n * Return the parsed comment of the given TypeScript node.\n *\n * @param node  The node whose comment should be returned.\n * @return The parsed comment as a [[Comment]] instance or NULL if\n *     no comment is present.\n */\nexport function createComment(node:ts.Node):Comment {\n    var comment = getRawComment(node);\n    if (comment == null) {\n        return null;\n    }\n\n    return parseComment(comment);\n}\n\n\n/**\n * Check whether the given module declaration is the topmost.\n *\n * This funtion returns TRUE if there is no trailing module defined, in\n * the following example this would be the case only for module <code>C</code>.\n *\n * ```\n * module A.B.C { }\n * ```\n *\n * @param node  The module definition that should be tested.\n * @return TRUE if the given node is the topmost module declaration, FALSE otherwise.\n */\nfunction isTopmostModuleDeclaration(node:ts.ModuleDeclaration):boolean {\n    if (node.nextContainer && node.nextContainer.kind == ts.SyntaxKind.ModuleDeclaration) {\n        let next = <ts.ModuleDeclaration>node.nextContainer;\n        if (node.name.end + 1 == next.name.pos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Return the root module declaration of the given module declaration.\n *\n * In the following example this function would always return module\n * <code>A</code> no matter which of the modules was passed in.\n *\n * ```\n * module A.B.C { }\n * ```\n */\nfunction getRootModuleDeclaration(node:ts.ModuleDeclaration):ts.Node\n{\n    while (node.parent && node.parent.kind == ts.SyntaxKind.ModuleDeclaration) {\n        let parent = <ts.ModuleDeclaration>node.parent;\n        if (node.name.pos == parent.name.end + 1) {\n            node = parent;\n        } else {\n            break;\n        }\n    }\n\n    return node;\n}\n\n\n/**\n * Return the raw comment string for the given node.\n *\n * @param node  The node whose comment should be resolved.\n * @returns     The raw comment string or NULL if no comment could be found.\n */\nexport function getRawComment(node:ts.Node):string {\n    if (node.parent && node.parent.kind === ts.SyntaxKind.VariableDeclarationList) {\n        node = node.parent.parent;\n    } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        if (!isTopmostModuleDeclaration(<ts.ModuleDeclaration>node)) {\n            return null;\n        } else {\n            node = getRootModuleDeclaration(<ts.ModuleDeclaration>node);\n        }\n    }\n\n    var sourceFile = ts.getSourceFileOfNode(node);\n    var comments = ts.getJsDocComments(node, sourceFile);\n    if (comments && comments.length) {\n        var comment:ts.CommentRange;\n        if (node.kind == ts.SyntaxKind.SourceFile) {\n            if (comments.length == 1) return null;\n            comment = comments[0];\n        } else {\n            comment = comments[comments.length - 1];\n        }\n\n        return sourceFile.text.substring(comment.pos, comment.end);\n    } else {\n        return null;\n    }\n}\n\n\n/**\n * Parse the given doc comment string.\n *\n * @param text     The doc comment string that should be parsed.\n * @param comment  The [[Models.Comment]] instance the parsed results should be stored into.\n * @returns        A populated [[Models.Comment]] instance.\n */\nexport function parseComment(text:string, comment:Comment = new Comment()):Comment {\n    var currentTag:CommentTag;\n    var shortText:number = 0;\n\n    function consumeTypeData(line:string):string {\n        line = line.replace(/^\\{[^\\}]*\\}+/, '');\n        line = line.replace(/^\\[[^\\[][^\\]]*\\]+/, '');\n        return line.trim();\n    }\n\n    function readBareLine(line:string) {\n        if (currentTag) {\n            currentTag.text += '\\n' + line;\n        } else if (line == '' && shortText == 0) {\n            // Ignore\n        } else if (line == '' && shortText == 1) {\n            shortText = 2;\n        } else {\n            if (shortText == 2) {\n                comment.text += (comment.text == '' ? '' : '\\n') + line;\n            } else {\n                comment.shortText += (comment.shortText == '' ? '' : '\\n') + line;\n                shortText = 1;\n            }\n        }\n    }\n\n    function readTagLine(line:string, tag:RegExpExecArray) {\n        var tagName = tag[1].toLowerCase();\n        line = line.substr(tagName.length + 1).trim();\n\n        if (tagName == 'return') tagName = 'returns';\n        if (tagName == 'param' || tagName == 'typeparam') {\n            line = consumeTypeData(line);\n            var param = /[^\\s]+/.exec(line);\n            if (param) {\n                var paramName = param[0];\n                line = line.substr(paramName.length + 1).trim();\n            }\n            line = consumeTypeData(line);\n            line = line.replace(/^\\-\\s+/, '');\n        } else if (tagName == 'returns') {\n            line = consumeTypeData(line);\n        }\n\n        currentTag = new CommentTag(tagName, paramName, line);\n        if (!comment.tags) comment.tags = [];\n        comment.tags.push(currentTag);\n    }\n\n    function readLine(line:string) {\n        line = line.replace(/^\\s*\\*? ?/, '');\n        line = line.replace(/\\s*$/, '');\n\n        var tag = /^@(\\w+)/.exec(line);\n        if (tag) {\n            readTagLine(line, tag);\n        } else {\n            readBareLine(line);\n        }\n    }\n\n    // text = text.replace(/^\\s*\\/\\*+\\s*(\\r\\n?|\\n)/, '');\n    // text = text.replace(/(\\r\\n?|\\n)\\s*\\*+\\/\\s*$/, '');\n    text = text.replace(/^\\s*\\/\\*+/, '');\n    text = text.replace(/\\*+\\/\\s*$/, '');\n    text.split(/\\r\\n?|\\n/).forEach(readLine);\n\n    return comment;\n}\n"]}