{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../src/lib/converter/factories/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\n\nimport {ReflectionKind, ReflectionFlag, ContainerReflection, DeclarationReflection} from \"../../models/index\";\nimport {Context} from \"../context\";\nimport {Converter} from \"../converter\";\nimport {createReferenceType} from \"./reference\";\n\n\n/**\n * List of reflection kinds that never should be static.\n */\nvar nonStaticKinds = [\n    ReflectionKind.Class,\n    ReflectionKind.Interface,\n    ReflectionKind.Module\n];\n\n\n/**\n * Create a declaration reflection from the given TypeScript node.\n *\n * @param context  The context object describing the current state the converter is in. The\n *   scope of the context will be the parent of the generated reflection.\n * @param node  The TypeScript node that should be converted to a reflection.\n * @param kind  The desired kind of the reflection.\n * @param name  The desired name of the reflection.\n * @returns The resulting reflection.\n */\nexport function createDeclaration(context:Context, node:ts.Node, kind:ReflectionKind, name?:string):DeclarationReflection {\n    var container = <ContainerReflection>context.scope;\n    if (!(container instanceof ContainerReflection)) {\n        throw new Error('Expected container reflection.');\n    }\n\n    // Ensure we have a name for the reflection\n    if (!name) {\n        if (node.localSymbol) {\n            name = node.localSymbol.name;\n        } else if (node.symbol) {\n            name = node.symbol.name;\n        } else {\n            return null;\n        }\n    }\n\n    // Test whether the node is exported\n    var isExported:boolean;\n    if (container.kindOf([ReflectionKind.Module, ReflectionKind.ExternalModule])) {\n        isExported = false; // Don't inherit exported state in modules and namespaces\n    } else {\n        isExported = container.flags.isExported;\n    }\n\n    if (kind == ReflectionKind.ExternalModule) {\n        isExported = true; // Always mark external modules as exported\n    } else if (node.parent && node.parent.kind == ts.SyntaxKind.VariableDeclarationList) {\n        isExported = isExported || !!(node.parent.parent.flags & ts.NodeFlags.Export)\n    } else {\n        isExported = isExported || !!(node.flags & ts.NodeFlags.Export);\n    }\n\n    if (!isExported && context.converter.excludeNotExported) {\n        return null;\n    }\n\n    // Test whether the node is private, when inheriting ignore private members\n    var isPrivate = !!(node.flags & ts.NodeFlags.Private);\n    if (context.isInherit && isPrivate) {\n        return null;\n    }\n\n    // Test whether the node is static, when merging a module to a class make the node static\n    var isConstructorProperty:boolean = false;\n    var isStatic = false;\n    if (nonStaticKinds.indexOf(kind) == -1) {\n        isStatic = !!(node.flags & ts.NodeFlags.Static);\n        if (container.kind == ReflectionKind.Class) {\n            if (node.parent && node.parent.kind == ts.SyntaxKind.Constructor) {\n                isConstructorProperty = true;\n            } else if (!node.parent || node.parent.kind != ts.SyntaxKind.ClassDeclaration) {\n                isStatic = true;\n            }\n        }\n    }\n\n    // Check if we already have a child with the same name and static flag\n    var child:DeclarationReflection;\n    var children = container.children = container.children || [];\n    children.forEach((n:DeclarationReflection) => {\n        if (n.name == name && n.flags.isStatic == isStatic) child = n;\n    });\n\n    if (!child) {\n        // Child does not exist, create a new reflection\n        child = new DeclarationReflection(container, name, kind);\n        child.setFlag(ReflectionFlag.Static, isStatic);\n        child.setFlag(ReflectionFlag.Private, isPrivate);\n        child.setFlag(ReflectionFlag.ConstructorProperty, isConstructorProperty);\n        child.setFlag(ReflectionFlag.Exported,  isExported);\n        child = setupDeclaration(context, child, node);\n\n        if (child) {\n            children.push(child);\n            context.registerReflection(child, node);\n        }\n    } else {\n        // Merge the existent reflection with the given node\n        child = mergeDeclarations(context, child, node, kind);\n    }\n\n    // If we have a reflection, trigger the corresponding event\n    if (child) {\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, child, node);\n    }\n\n    return child;\n}\n\n\n/**\n * Setup a newly created declaration reflection.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param reflection  The newly created blank reflection.\n * @param node  The TypeScript node whose properties should be applies to the given reflection.\n * @returns The reflection populated with the values of the given node.\n */\nfunction setupDeclaration(context:Context, reflection:DeclarationReflection, node:ts.Node) {\n    reflection.setFlag(ReflectionFlag.External,  context.isExternal);\n    reflection.setFlag(ReflectionFlag.Protected, !!(node.flags & ts.NodeFlags.Protected));\n    reflection.setFlag(ReflectionFlag.Public,    !!(node.flags & ts.NodeFlags.Public));\n    reflection.setFlag(ReflectionFlag.Optional,  !!(node['questionToken']));\n\n    if (\n        context.isInherit &&\n        (node.parent == context.inheritParent || reflection.flags.isConstructorProperty)\n    ) {\n        if (!reflection.inheritedFrom) {\n            reflection.inheritedFrom = createReferenceType(context, node.symbol, true);\n            reflection.getAllSignatures().forEach((signature) => {\n                signature.inheritedFrom = createReferenceType(context, node.symbol, true);\n            });\n        }\n    }\n\n    return reflection;\n}\n\n\n/**\n * Merge the properties of the given TypeScript node with the pre existent reflection.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param reflection  The pre existent reflection.\n * @param node  The TypeScript node whose properties should be merged with the given reflection.\n * @param kind  The desired kind of the reflection.\n * @returns The reflection merged with the values of the given node or NULL if the merge is invalid.\n */\nfunction mergeDeclarations(context:Context, reflection:DeclarationReflection, node:ts.Node, kind:ReflectionKind) {\n    if (reflection.kind != kind) {\n        var weights = [ReflectionKind.Module, ReflectionKind.Enum, ReflectionKind.Class];\n        var kindWeight = weights.indexOf(kind);\n        var childKindWeight = weights.indexOf(reflection.kind);\n        if (kindWeight > childKindWeight) {\n            reflection.kind = kind;\n        }\n    }\n\n    if (\n        context.isInherit &&\n        context.inherited.indexOf(reflection.name) != -1 &&\n        (node.parent == context.inheritParent || reflection.flags.isConstructorProperty)\n    ) {\n        if (!reflection.overwrites) {\n            reflection.overwrites = createReferenceType(context, node.symbol, true);\n            reflection.getAllSignatures().forEach((signature) => {\n                signature.overwrites = createReferenceType(context, node.symbol, true);\n            });\n        }\n        return null;\n    }\n\n    return reflection;\n}\n"]}