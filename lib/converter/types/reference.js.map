{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../src/lib/converter/types/reference.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAY,EAAE,WAAM,YAAY,CAAC,CAAA;AAEjC,sBAAkD,0BAA0B,CAAC,CAAA;AAC7E,sBAAoD,gCAAgC,CAAC,CAAA;AACrF,sBAAkC,oBAAoB,CAAC,CAAA;AACvD,2BAAoE,eAAe,CAAC,CAAA;AAEpF,0BAAwB,cAAc,CAAC,CAAA;AAIvC;IAAwC,sCAAsB;IAA9D;QAAwC,8BAAsB;QAM1D,aAAQ,GAAU,CAAC,EAAE,CAAC;IAkI1B,CAAC;IA3HG,yCAAY,GAAZ,UAAa,OAAe,EAAE,IAAyB,EAAE,IAAqB;QAC1E,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,OAAuB,CAAC,CAAC;IACpD,CAAC;IAMD,yCAAY,GAAZ,UAAa,OAAe,EAAE,IAAqB;QAC/C,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,OAAuB,CAAC,CAAC;IACpD,CAAC;IAkBD,wCAAW,GAAX,UAAY,OAAe,EAAE,IAAyB,EAAE,IAAqB;QAA7E,iBAaC;QAZG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,IAAI,qBAAa,CAAC,QAAQ,CAAC,CAAC;QACvC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,IAA0B,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,IAA4B,CAAC,CAAC,CAAC;YAC5G,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,MAAM,GAAG,2BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACvD,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC,EAAlC,CAAkC,CAAC,CAAC;QAC7F,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAiBD,wCAAW,GAAX,UAAY,OAAe,EAAE,IAAqB;QAAlD,iBAaC;QAZG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,IAAI,qBAAa,CAAC,QAAQ,CAAC,CAAC;QACvC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,IAA0B,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,IAA4B,CAAC,CAAC,CAAC;YAC5G,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACrD,CAAC;QAED,IAAI,MAAM,GAAG,2BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACvD,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACrB,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,EAAxC,CAAwC,CAAC,CAAC;QACnG,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAyBO,2CAAc,GAAtB,UAAuB,OAAe,EAAE,MAAgB,EAAE,IAAa;QAAvE,iBA0BC;QAzBG,GAAG,CAAC,CAAoB,UAAmB,EAAnB,KAAA,MAAM,CAAC,YAAY,EAAnB,cAAmB,EAAnB,IAAmB,CAAC;YAAvC,IAAI,aAAW,SAAA;YAChB,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,aAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACjD,EAAE,CAAC,CAAC,aAAW,CAAC,IAAI,IAAI,GAAyB;oBACzC,aAAW,CAAC,IAAI,IAAI,GAAqC,CAAC,CAAC,CAAC;oBAChE,MAAM,CAAC,2BAAmB,CAAC,OAAO,EAAE,aAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBACnE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,MAAM,CAAC,2BAAmB,CAAC,OAAO,EAAE,aAAW,CAAC,MAAM,CAAC,CAAC;gBAC5D,CAAC;YACL,CAAC;SACJ;QAED,IAAI,WAAW,GAAG,IAAI,6BAAqB,EAAE,CAAC;QAC9C,WAAW,CAAC,IAAI,GAAG,sBAAc,CAAC,WAAW,CAAC;QAC9C,WAAW,CAAC,IAAI,GAAG,QAAQ,CAAC;QAC5B,WAAW,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC;QAEnC,OAAO,CAAC,kBAAkB,CAAC,WAAW,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QACtD,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,wBAAwB,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;QACvE,OAAO,CAAC,SAAS,CAAC,WAAW,EAAE;YAC3B,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,IAAI;gBAC7B,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;YAC1C,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,IAAI,sBAAc,CAAC,WAAW,CAAC,CAAC;IAC3C,CAAC;IAxIL;QAAC,sBAAS,CAAC,EAAC,IAAI,EAAC,gBAAgB,EAAC,CAAC;0BAAA;IAyInC,yBAAC;AAAD,CAAC,AAxID,CAAwC,mCAAsB,GAwI7D;AAxIY,0BAAkB,qBAwI9B,CAAA","sourcesContent":["import * as ts from \"typescript\";\n\nimport {Type, IntrinsicType, ReflectionType} from \"../../models/types/index\";\nimport {ReflectionKind, DeclarationReflection} from \"../../models/reflections/index\";\nimport {createReferenceType} from \"../factories/index\";\nimport {Component, ConverterTypeComponent, ITypeNodeConverter} from \"../components\";\nimport {Context} from \"../context\";\nimport {Converter} from \"../converter\";\n\n\n@Component({name:'type:reference'})\nexport class ReferenceConverter extends ConverterTypeComponent implements ITypeNodeConverter<ts.TypeReference, ts.TypeReferenceNode>\n{\n    /**\n     * The priority this converter should be executed with.\n     * A higher priority means the converter will be applied earlier.\n     */\n    priority:number = -50;\n\n\n\n    /**\n     * Test whether this converter can handle the given TypeScript node.\n     */\n    supportsNode(context:Context, node:ts.TypeReferenceNode, type:ts.TypeReference):boolean {\n        return !!(type.flags & ts.TypeFlags.ObjectType);\n    }\n\n\n    /**\n     * Test whether this converter can handle the given TypeScript type.\n     */\n    supportsType(context:Context, type:ts.TypeReference):boolean {\n        return !!(type.flags & ts.TypeFlags.ObjectType);\n    }\n\n\n    /**\n     * Convert the type reference node to its type reflection.\n     *\n     * This is a node based converter, see [[convertTypeReferenceType]] for the type equivalent.\n     *\n     * ```\n     * class SomeClass { }\n     * var someValue:SomeClass;\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param node  The type reference node that should be converted.\n     * @param type  The type of the type reference node.\n     * @returns The type reflection representing the given reference node.\n     */\n    convertNode(context:Context, node:ts.TypeReferenceNode, type:ts.TypeReference):Type {\n        if (!type.symbol) {\n            return new IntrinsicType('Object');\n        } else if (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral) {\n            return this.convertLiteral(context, type.symbol, node);\n        }\n\n        var result = createReferenceType(context, type.symbol);\n        if (node.typeArguments) {\n            result.typeArguments = node.typeArguments.map((n) => this.owner.convertType(context, n));\n        }\n\n        return result;\n    }\n\n\n    /**\n     * Convert the given type reference to its type reflection.\n     *\n     * This is a type based converter, see [[convertTypeReference]] for the node equivalent.\n     *\n     * ```\n     * class SomeClass { }\n     * var someValue:SomeClass;\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param type  The type reference that should be converted.\n     * @returns The type reflection representing the given type reference.\n     */\n    convertType(context:Context, type:ts.TypeReference):Type {\n        if (!type.symbol) {\n            return new IntrinsicType('Object');\n        } else if (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral) {\n            return this.convertLiteral(context, type.symbol);\n        }\n\n        var result = createReferenceType(context, type.symbol);\n        if (type.typeArguments) {\n            result.typeArguments = type.typeArguments.map((t) => this.owner.convertType(context, null, t));\n        }\n\n        return result;\n    }\n\n\n    /**\n     * Create a type literal reflection.\n     *\n     * This is a utility function used by [[convertTypeReferenceNode]] and\n     * [[convertTypeReferenceType]] when encountering an object or type literal.\n     *\n     * A type literal is explicitly set:\n     * ```\n     * var someValue:{a:string; b:number;};\n     * ```\n     *\n     * An object literal types are usually reflected by the TypeScript compiler:\n     * ```\n     * function someFunction() { return {a:'Test', b:1024}; }\n     * ```\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param symbol  The symbol describing the type literal.\n     * @param node  If known the node which produced the type literal. Type literals that are\n     *   implicitly generated by TypeScript won't have a corresponding node.\n     * @returns A type reflection representing the given type literal.\n     */\n    private convertLiteral(context:Context, symbol:ts.Symbol, node?:ts.Node):Type {\n        for (let declaration of symbol.declarations) {\n            if (context.visitStack.indexOf(declaration) !== -1) {\n                if (declaration.kind == ts.SyntaxKind.TypeLiteral ||\n                        declaration.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n                    return createReferenceType(context, declaration.parent.symbol);\n                } else {\n                    return createReferenceType(context, declaration.symbol);\n                }\n            }\n        }\n\n        var declaration = new DeclarationReflection();\n        declaration.kind = ReflectionKind.TypeLiteral;\n        declaration.name = '__type';\n        declaration.parent = context.scope;\n\n        context.registerReflection(declaration, null, symbol);\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, declaration, node);\n        context.withScope(declaration, () => {\n            symbol.declarations.forEach((node) => {\n                this.owner.convertNode(context, node);\n            });\n        });\n\n        return new ReflectionType(declaration);\n    }\n}\n"]}