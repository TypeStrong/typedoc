{"version":3,"file":"components.js","sourceRoot":"","sources":["../../src/lib/converter/components.ts"],"names":[],"mappings":";;;;;;AAGA,0BAA2C,oBAAoB,CAAC,CAAA;AAOxD,iBAAS;AAGjB;IAAiD,sCAA4B;IAA7E;QAAiD,8BAA4B;IAAG,CAAC;IAAD,yBAAC;AAAD,CAAC,AAAjF,CAAiD,6BAAiB,GAAe;AAA3D,0BAAkB,qBAAyC,CAAA;AAGjF;IAAwE,0CAAkB;IAA1F;QAAwE,8BAAkB;IAS1F,CAAC;IAAD,6BAAC;AAAD,CAAC,AATD,CAAwE,kBAAkB,GASzF;AATqB,8BAAsB,yBAS3C,CAAA;AAGD;IAAqD,0CAAkB;IAAvE;QAAqD,8BAAkB;QAMnE,aAAQ,GAAU,CAAC,CAAC;IACxB,CAAC;IAAD,6BAAC;AAAD,CAAC,AAPD,CAAqD,kBAAkB,GAOtE;AAPqB,8BAAsB,yBAO3C,CAAA","sourcesContent":["import * as ts from \"typescript\";\n\nimport {Application} from \"../application\";\nimport {Component, AbstractComponent} from \"../utils/component\";\nimport {Reflection} from \"../models/reflections/abstract\";\nimport {Type} from \"../models/types/abstract\";\nimport {Context} from \"./context\";\nimport {Converter} from \"./converter\";\n\n\nexport {Component};\n\n\nexport abstract class ConverterComponent extends AbstractComponent<Converter> { }\n\n\nexport abstract class ConverterNodeComponent<T extends ts.Node> extends ConverterComponent\n{\n    /**\n     * List of supported TypeScript syntax kinds.\n     */\n    supports:ts.SyntaxKind[];\n\n\n    abstract convert(context:Context, node:T):Reflection;\n}\n\n\nexport abstract class ConverterTypeComponent extends ConverterComponent\n{\n    /**\n     * The priority this converter should be executed with.\n     * A higher priority means the converter will be applied earlier.\n     */\n    priority:number = 0;\n}\n\n\nexport interface ITypeConverter<T extends ts.Type, N extends ts.Node>\n        extends ConverterTypeComponent, ITypeTypeConverter<T>, ITypeNodeConverter<T, N> {}\n\n\nexport interface ITypeTypeConverter<T extends ts.Type> extends ConverterTypeComponent\n{\n    /**\n     * Test whether this converter can handle the given TypeScript type.\n     */\n    supportsType(context:Context, type:T):boolean;\n\n    /**\n     * Convert the given type to its type reflection.\n     */\n    convertType(context:Context, type:T):Type;\n}\n\n\nexport interface ITypeNodeConverter<T extends ts.Type, N extends ts.Node> extends ConverterTypeComponent\n{\n    /**\n     * Test whether this converter can handle the given TypeScript node.\n     */\n    supportsNode(context:Context, node:N, type:T):boolean;\n\n    /**\n     * Convert the given type node to its type reflection.\n     */\n    convertNode(context:Context, node:N, type:T):Type;\n}\n"]}